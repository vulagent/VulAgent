[
  {
    "role": "system",
    "content": "Next, the calls to the three functions EARLYSTOP, PRUNE, and CODESLICE that invoke the large model will be recorded."
  },
  {
    "role": "user",
    "content": "PRUNE: ['1389: /*\\n1390: ** Interpret zArg as an integer value, possibly with suffixes.\\n1391: */\\n1392: static sqlite3_int64 integerValue(const char *zArg){\\n1393:   sqlite3_int64 v = 0;\\n1394:   static const struct { char *zSuffix; int iMult; } aMult[] = {\\n1395:     { \"KiB\", 1024 },\\n1396:     { \"MiB\", 1024*1024 },\\n1397:     { \"GiB\", 1024*1024*1024 },\\n1398:     { \"KB\",  1000 },\\n1399:     { \"MB\",  1000000 },\\n1400:     { \"GB\",  1000000000 },\\n1401:     { \"K\",   1000 },\\n1402:     { \"M\",   1000000 },\\n1403:     { \"G\",   1000000000 },\\n1404:   };\\n1405:   int i;\\n1406:   int isNeg = 0;\\n1407:   if( zArg[0]==\\'-\\' ){\\n1408:     isNeg = 1;\\n1409:     zArg++;\\n1410:   }else if( zArg[0]==\\'+\\' ){\\n1411:     zArg++;\\n1412:   }\\n1413:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n1414:     int x;\\n1415:     zArg += 2;\\n1416:     while( (x = hexDigitValue(zArg[0]))>=0 ){\\n1417:       v = (v<<4) + x;\\n1418:       zArg++;\\n1419:     }\\n1420:   }else{\\n1421:     while( IsDigit(zArg[0]) ){\\n1422:       v = v*10 + zArg[0] - \\'0\\';\\n1423:       zArg++;\\n1424:     }\\n1425:   }\\n1426:   for(i=0; i<ArraySize(aMult); i++){\\n1427:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n1428:       v *= aMult[i].iMult;\\n1429:       break;\\n1430:     }\\n1431:   }\\n1432:   return isNeg? -v : v;\\n1433: }\\n732: /*\\n733: ** Interpret zArg as an integer value, possibly with suffixes.\\n734: */\\n735: static int integerValue(const char *zArg){\\n736:   sqlite3_int64 v = 0;\\n737:   static const struct { char *zSuffix; int iMult; } aMult[] = {\\n738:     { \"KiB\", 1024 },\\n739:     { \"MiB\", 1024*1024 },\\n740:     { \"GiB\", 1024*1024*1024 },\\n741:     { \"KB\",  1000 },\\n742:     { \"MB\",  1000000 },\\n743:     { \"GB\",  1000000000 },\\n744:     { \"K\",   1000 },\\n745:     { \"M\",   1000000 },\\n746:     { \"G\",   1000000000 },\\n747:   };\\n748:   int i;\\n749:   int isNeg = 0;\\n750:   if( zArg[0]==\\'-\\' ){\\n751:     isNeg = 1;\\n752:     zArg++;\\n753:   }else if( zArg[0]==\\'+\\' ){\\n754:     zArg++;\\n755:   }\\n756:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n757:     int x;\\n758:     zArg += 2;\\n759:     while( (x = hexDigitValue(zArg[0]))>=0 ){\\n760:       v = (v<<4) + x;\\n761:       zArg++;\\n762:     }\\n763:   }else{\\n764:     while( ISDIGIT(zArg[0]) ){\\n765:       v = v*10 + zArg[0] - \\'0\\';\\n766:       zArg++;\\n767:     }\\n768:   }\\n769:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\\n770:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n771:       v *= aMult[i].iMult;\\n772:       break;\\n773:     }\\n774:   }\\n775:   if( v>0x7fffffff ) abendError(\"parameter too large - max 2147483648\");\\n776:   return (int)(isNeg? -v : v);\\n777: }\\n427: /*\\n428: ** Interpret zArg as an integer value, possibly with suffixes.\\n429: */\\n430: static int integerValue(const char *zArg){\\n431:   sqlite3_int64 v = 0;\\n432:   static const struct { char *zSuffix; int iMult; } aMult[] = {\\n433:     { \"KiB\", 1024 },\\n434:     { \"MiB\", 1024*1024 },\\n435:     { \"GiB\", 1024*1024*1024 },\\n436:     { \"KB\",  1000 },\\n437:     { \"MB\",  1000000 },\\n438:     { \"GB\",  1000000000 },\\n439:     { \"K\",   1000 },\\n440:     { \"M\",   1000000 },\\n441:     { \"G\",   1000000000 },\\n442:   };\\n443:   int i;\\n444:   int isNeg = 0;\\n445:   if( zArg[0]==\\'-\\' ){\\n446:     isNeg = 1;\\n447:     zArg++;\\n448:   }else if( zArg[0]==\\'+\\' ){\\n449:     zArg++;\\n450:   }\\n451:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n452:     int x;\\n453:     zArg += 2;\\n454:     while( (x = hexDigitValue(zArg[0]))>=0 ){\\n455:       v = (v<<4) + x;\\n456:       zArg++;\\n457:     }\\n458:   }else{\\n459:     while( isdigit(zArg[0]) ){\\n460:       v = v*10 + zArg[0] - \\'0\\';\\n461:       zArg++;\\n462:     }\\n463:   }\\n464:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\\n465:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n466:       v *= aMult[i].iMult;\\n467:       break;\\n468:     }\\n469:   }\\n470:   if( v>0x7fffffff ){\\n471:     printf(\"ERROR: parameter too large - max 2147483648\\\\n\");\\n472:     exit(1);\\n473:   }\\n474:   return (int)(isNeg? -v : v);\\n475: }\\n498: /*\\n499: ** Interpret zArg as an integer value, possibly with suffixes.\\n500: */\\n501: static int integerValue(const char *zArg){\\n502:   sqlite3_int64 v = 0;\\n503:   static const struct { char *zSuffix; int iMult; } aMult[] = {\\n504:     { \"KiB\", 1024 },\\n505:     { \"MiB\", 1024*1024 },\\n506:     { \"GiB\", 1024*1024*1024 },\\n507:     { \"KB\",  1000 },\\n508:     { \"MB\",  1000000 },\\n509:     { \"GB\",  1000000000 },\\n510:     { \"K\",   1000 },\\n511:     { \"M\",   1000000 },\\n512:     { \"G\",   1000000000 },\\n513:   };\\n514:   int i;\\n515:   int isNeg = 0;\\n516:   if( zArg[0]==\\'-\\' ){\\n517:     isNeg = 1;\\n518:     zArg++;\\n519:   }else if( zArg[0]==\\'+\\' ){\\n520:     zArg++;\\n521:   }\\n522:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n523:     int x;\\n524:     zArg += 2;\\n525:     while( (x = hexDigitValue(zArg[0]))>=0 ){\\n526:       v = (v<<4) + x;\\n527:       zArg++;\\n528:     }\\n529:   }else{\\n530:     while( ISDIGIT(zArg[0]) ){\\n531:       v = v*10 + zArg[0] - \\'0\\';\\n532:       zArg++;\\n533:     }\\n534:   }\\n535:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\\n536:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n537:       v *= aMult[i].iMult;\\n538:       break;\\n539:     }\\n540:   }\\n541:   if( v>0x7fffffff ) fatalError(\"parameter too large - max 2147483648\");\\n542:   return (int)(isNeg? -v : v);\\n543: }\\n195: /*\\n196: ** Interpret zArg as an integer value, possibly with suffixes.\\n197: */\\n198: static int integerValue(const char *zArg){\\n199:   int v = 0;\\n200:   static const struct { char *zSuffix; int iMult; } aMult[] = {\\n201:     { \"KiB\", 1024 },\\n202:     { \"MiB\", 1024*1024 },\\n203:     { \"GiB\", 1024*1024*1024 },\\n204:     { \"KB\",  1000 },\\n205:     { \"MB\",  1000000 },\\n206:     { \"GB\",  1000000000 },\\n207:     { \"K\",   1000 },\\n208:     { \"M\",   1000000 },\\n209:     { \"G\",   1000000000 },\\n210:   };\\n211:   int i;\\n212:   int isNeg = 0;\\n213:   if( zArg[0]==\\'-\\' ){\\n214:     isNeg = 1;\\n215:     zArg++;\\n216:   }else if( zArg[0]==\\'+\\' ){\\n217:     zArg++;\\n218:   }\\n219:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n220:     int x;\\n221:     zArg += 2;\\n222:     while( (x = hexDigitValue(zArg[0]))>=0 ){\\n223:       v = (v<<4) + x;\\n224:       zArg++;\\n225:     }\\n226:   }else{\\n227:     while( zArg[0]>=\\'0\\' && zArg[0]<=\\'9\\' ){\\n228:       v = v*10 + zArg[0] - \\'0\\';\\n229:       zArg++;\\n230:     }\\n231:   }\\n232:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\\n233:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n234:       v *= aMult[i].iMult;\\n235:       break;\\n236:     }\\n237:   }\\n238:   return isNeg? -v : v;\\n239: }\\n246: /*\\n247: ** Interpret zArg as an integer value, possibly with suffixes.\\n248: */\\n249: static int integerValue(const char *zArg){\\n250:   sqlite3_int64 v = 0;\\n251:   static const struct { char *zSuffix; int iMult; } aMult[] = {\\n252:     { \"KiB\", 1024 },\\n253:     { \"MiB\", 1024*1024 },\\n254:     { \"GiB\", 1024*1024*1024 },\\n255:     { \"KB\",  1000 },\\n256:     { \"MB\",  1000000 },\\n257:     { \"GB\",  1000000000 },\\n258:     { \"K\",   1000 },\\n259:     { \"M\",   1000000 },\\n260:     { \"G\",   1000000000 },\\n261:   };\\n262:   int i;\\n263:   int isNeg = 0;\\n264:   if( zArg[0]==\\'-\\' ){\\n265:     isNeg = 1;\\n266:     zArg++;\\n267:   }else if( zArg[0]==\\'+\\' ){\\n268:     zArg++;\\n269:   }\\n270:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n271:     int x;\\n272:     zArg += 2;\\n273:     while( (x = hexDigitValue(zArg[0]))>=0 ){\\n274:       v = (v<<4) + x;\\n275:       zArg++;\\n276:     }\\n277:   }else{\\n278:     while( isdigit(zArg[0]) ){\\n279:       v = v*10 + zArg[0] - \\'0\\';\\n280:       zArg++;\\n281:     }\\n282:   }\\n283:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\\n284:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n285:       v *= aMult[i].iMult;\\n286:       break;\\n287:     }\\n288:   }\\n289:   if( v>0x7fffffff ) fatal_error(\"parameter too large - max 2147483648\");\\n290:   return (int)(isNeg? -v : v);\\n291: }\\n']"
  },
  {
    "role": "assistant",
    "content": "The vulnerable line `v *= aMult[i].iMult;` multiplies a signed 64-bit integer `v` by a signed 32-bit integer `iMult`. There is no explicit overflow check before this multiplication, and the multiplication result is stored in the same signed 64-bit type. Later, the value `v` is checked against the 32-bit signed max (0x7fffffff) before narrowing to int, but this check occurs after the multiplication. Since `v` can be large before multiplication and `iMult` can be up to 1,000,000,000, the multiplication can overflow the 64-bit signed integer range, causing undefined behavior.\n\n- The code does not perform checked arithmetic (E).\n- There is no prior range check ensuring `v * iMult` fits in 64-bit signed range (B).\n- The multiplication is done in 64-bit signed type, but no guard prevents overflow (C not fully met).\n- No special handling for unary minus or shifts applies here (F, D irrelevant).\n- The narrowing cast to int happens after the multiplication and a range check, but the overflow can occur during multiplication itself.\n\nTherefore, signed integer overflow is possible on this path.\n\n@@@may vulnerability@@@"
  },
  {
    "role": "user",
    "content": "CODESLICE: 1389: /*\n1390: ** Interpret zArg as an integer value, possibly with suffixes.\n1391: */\n1392: static sqlite3_int64 integerValue(const char *zArg){\n1393:   sqlite3_int64 v = 0;\n1394:   static const struct { char *zSuffix; int iMult; } aMult[] = {\n1395:     { \"KiB\", 1024 },\n1396:     { \"MiB\", 1024*1024 },\n1397:     { \"GiB\", 1024*1024*1024 },\n1398:     { \"KB\",  1000 },\n1399:     { \"MB\",  1000000 },\n1400:     { \"GB\",  1000000000 },\n1401:     { \"K\",   1000 },\n1402:     { \"M\",   1000000 },\n1403:     { \"G\",   1000000000 },\n1404:   };\n1405:   int i;\n1406:   int isNeg = 0;\n1407:   if( zArg[0]=='-' ){\n1408:     isNeg = 1;\n1409:     zArg++;\n1410:   }else if( zArg[0]=='+' ){\n1411:     zArg++;\n1412:   }\n1413:   if( zArg[0]=='0' && zArg[1]=='x' ){\n1414:     int x;\n1415:     zArg += 2;\n1416:     while( (x = hexDigitValue(zArg[0]))>=0 ){\n1417:       v = (v<<4) + x;\n1418:       zArg++;\n1419:     }\n1420:   }else{\n1421:     while( IsDigit(zArg[0]) ){\n1422:       v = v*10 + zArg[0] - '0';\n1423:       zArg++;\n1424:     }\n1425:   }\n1426:   for(i=0; i<ArraySize(aMult); i++){\n1427:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n1428:       v *= aMult[i].iMult;\n1429:       break;\n1430:     }\n1431:   }\n1432:   return isNeg? -v : v;\n1433: }\n732: /*\n733: ** Interpret zArg as an integer value, possibly with suffixes.\n734: */\n735: static int integerValue(const char *zArg){\n736:   sqlite3_int64 v = 0;\n737:   static const struct { char *zSuffix; int iMult; } aMult[] = {\n738:     { \"KiB\", 1024 },\n739:     { \"MiB\", 1024*1024 },\n740:     { \"GiB\", 1024*1024*1024 },\n741:     { \"KB\",  1000 },\n742:     { \"MB\",  1000000 },\n743:     { \"GB\",  1000000000 },\n744:     { \"K\",   1000 },\n745:     { \"M\",   1000000 },\n746:     { \"G\",   1000000000 },\n747:   };\n748:   int i;\n749:   int isNeg = 0;\n750:   if( zArg[0]=='-' ){\n751:     isNeg = 1;\n752:     zArg++;\n753:   }else if( zArg[0]=='+' ){\n754:     zArg++;\n755:   }\n756:   if( zArg[0]=='0' && zArg[1]=='x' ){\n757:     int x;\n758:     zArg += 2;\n759:     while( (x = hexDigitValue(zArg[0]))>=0 ){\n760:       v = (v<<4) + x;\n761:       zArg++;\n762:     }\n763:   }else{\n764:     while( ISDIGIT(zArg[0]) ){\n765:       v = v*10 + zArg[0] - '0';\n766:       zArg++;\n767:     }\n768:   }\n769:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\n770:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n771:       v *= aMult[i].iMult;\n772:       break;\n773:     }\n774:   }\n775:   if( v>0x7fffffff ) abendError(\"parameter too large - max 2147483648\");\n776:   return (int)(isNeg? -v : v);\n777: }\n427: /*\n428: ** Interpret zArg as an integer value, possibly with suffixes.\n429: */\n430: static int integerValue(const char *zArg){\n431:   sqlite3_int64 v = 0;\n432:   static const struct { char *zSuffix; int iMult; } aMult[] = {\n433:     { \"KiB\", 1024 },\n434:     { \"MiB\", 1024*1024 },\n435:     { \"GiB\", 1024*1024*1024 },\n436:     { \"KB\",  1000 },\n437:     { \"MB\",  1000000 },\n438:     { \"GB\",  1000000000 },\n439:     { \"K\",   1000 },\n440:     { \"M\",   1000000 },\n441:     { \"G\",   1000000000 },\n442:   };\n443:   int i;\n444:   int isNeg = 0;\n445:   if( zArg[0]=='-' ){\n446:     isNeg = 1;\n447:     zArg++;\n448:   }else if( zArg[0]=='+' ){\n449:     zArg++;\n450:   }\n451:   if( zArg[0]=='0' && zArg[1]=='x' ){\n452:     int x;\n453:     zArg += 2;\n454:     while( (x = hexDigitValue(zArg[0]))>=0 ){\n455:       v = (v<<4) + x;\n456:       zArg++;\n457:     }\n458:   }else{\n459:     while( isdigit(zArg[0]) ){\n460:       v = v*10 + zArg[0] - '0';\n461:       zArg++;\n462:     }\n463:   }\n464:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\n465:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n466:       v *= aMult[i].iMult;\n467:       break;\n468:     }\n469:   }\n470:   if( v>0x7fffffff ){\n471:     printf(\"ERROR: parameter too large - max 2147483648\\n\");\n472:     exit(1);\n473:   }\n474:   return (int)(isNeg? -v : v);\n475: }\n498: /*\n499: ** Interpret zArg as an integer value, possibly with suffixes.\n500: */\n501: static int integerValue(const char *zArg){\n502:   sqlite3_int64 v = 0;\n503:   static const struct { char *zSuffix; int iMult; } aMult[] = {\n504:     { \"KiB\", 1024 },\n505:     { \"MiB\", 1024*1024 },\n506:     { \"GiB\", 1024*1024*1024 },\n507:     { \"KB\",  1000 },\n508:     { \"MB\",  1000000 },\n509:     { \"GB\",  1000000000 },\n510:     { \"K\",   1000 },\n511:     { \"M\",   1000000 },\n512:     { \"G\",   1000000000 },\n513:   };\n514:   int i;\n515:   int isNeg = 0;\n516:   if( zArg[0]=='-' ){\n517:     isNeg = 1;\n518:     zArg++;\n519:   }else if( zArg[0]=='+' ){\n520:     zArg++;\n521:   }\n522:   if( zArg[0]=='0' && zArg[1]=='x' ){\n523:     int x;\n524:     zArg += 2;\n525:     while( (x = hexDigitValue(zArg[0]))>=0 ){\n526:       v = (v<<4) + x;\n527:       zArg++;\n528:     }\n529:   }else{\n530:     while( ISDIGIT(zArg[0]) ){\n531:       v = v*10 + zArg[0] - '0';\n532:       zArg++;\n533:     }\n534:   }\n535:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\n536:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n537:       v *= aMult[i].iMult;\n538:       break;\n539:     }\n540:   }\n541:   if( v>0x7fffffff ) fatalError(\"parameter too large - max 2147483648\");\n542:   return (int)(isNeg? -v : v);\n543: }\n195: /*\n196: ** Interpret zArg as an integer value, possibly with suffixes.\n197: */\n198: static int integerValue(const char *zArg){\n199:   int v = 0;\n200:   static const struct { char *zSuffix; int iMult; } aMult[] = {\n201:     { \"KiB\", 1024 },\n202:     { \"MiB\", 1024*1024 },\n203:     { \"GiB\", 1024*1024*1024 },\n204:     { \"KB\",  1000 },\n205:     { \"MB\",  1000000 },\n206:     { \"GB\",  1000000000 },\n207:     { \"K\",   1000 },\n208:     { \"M\",   1000000 },\n209:     { \"G\",   1000000000 },\n210:   };\n211:   int i;\n212:   int isNeg = 0;\n213:   if( zArg[0]=='-' ){\n214:     isNeg = 1;\n215:     zArg++;\n216:   }else if( zArg[0]=='+' ){\n217:     zArg++;\n218:   }\n219:   if( zArg[0]=='0' && zArg[1]=='x' ){\n220:     int x;\n221:     zArg += 2;\n222:     while( (x = hexDigitValue(zArg[0]))>=0 ){\n223:       v = (v<<4) + x;\n224:       zArg++;\n225:     }\n226:   }else{\n227:     while( zArg[0]>='0' && zArg[0]<='9' ){\n228:       v = v*10 + zArg[0] - '0';\n229:       zArg++;\n230:     }\n231:   }\n232:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\n233:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n234:       v *= aMult[i].iMult;\n235:       break;\n236:     }\n237:   }\n238:   return isNeg? -v : v;\n239: }\n246: /*\n247: ** Interpret zArg as an integer value, possibly with suffixes.\n248: */\n249: static int integerValue(const char *zArg){\n250:   sqlite3_int64 v = 0;\n251:   static const struct { char *zSuffix; int iMult; } aMult[] = {\n252:     { \"KiB\", 1024 },\n253:     { \"MiB\", 1024*1024 },\n254:     { \"GiB\", 1024*1024*1024 },\n255:     { \"KB\",  1000 },\n256:     { \"MB\",  1000000 },\n257:     { \"GB\",  1000000000 },\n258:     { \"K\",   1000 },\n259:     { \"M\",   1000000 },\n260:     { \"G\",   1000000000 },\n261:   };\n262:   int i;\n263:   int isNeg = 0;\n264:   if( zArg[0]=='-' ){\n265:     isNeg = 1;\n266:     zArg++;\n267:   }else if( zArg[0]=='+' ){\n268:     zArg++;\n269:   }\n270:   if( zArg[0]=='0' && zArg[1]=='x' ){\n271:     int x;\n272:     zArg += 2;\n273:     while( (x = hexDigitValue(zArg[0]))>=0 ){\n274:       v = (v<<4) + x;\n275:       zArg++;\n276:     }\n277:   }else{\n278:     while( isdigit(zArg[0]) ){\n279:       v = v*10 + zArg[0] - '0';\n280:       zArg++;\n281:     }\n282:   }\n283:   for(i=0; i<sizeof(aMult)/sizeof(aMult[0]); i++){\n284:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n285:       v *= aMult[i].iMult;\n286:       break;\n287:     }\n288:   }\n289:   if( v>0x7fffffff ) fatal_error(\"parameter too large - max 2147483648\");\n290:   return (int)(isNeg? -v : v);\n291: }\n"
  },
  {
    "role": "assistant",
    "content": "Analysis:\n\n1. The vulnerability description points to an arithmetic operation on user-controlled data without validation, specifically the line:\n   ```\n   v *= aMult[i].iMult;\n   ```\n   This multiplication can cause integer overflow.\n\n2. The key variables involved are:\n   - `v`: the integer value being computed.\n   - `aMult[i].iMult`: the multiplier corresponding to a suffix.\n\n3. The control flow relevant to the vulnerability is the loop that checks if the suffix matches and then multiplies `v` by the multiplier.\n\n4. The rest of the function involves parsing the input string `zArg` to extract the numeric part and suffix, handling signs, and hexadecimal or decimal parsing.\n\n5. Since the vulnerability is about unchecked multiplication that can overflow, the relevant code includes:\n   - Initialization of `v`.\n   - The suffix multiplier array `aMult`.\n   - The loop that matches suffix and multiplies `v`.\n   - The parsing of the numeric part to get `v`.\n   - The sign handling.\n   \n6. Unrelated code such as detailed parsing loops, hex digit extraction, and the return statement can be summarized in natural language.\n\n7. The final reduced function should keep the vulnerable multiplication line and the context around it, including the suffix array and sign handling, but can summarize the parsing steps.\n\nReduced function body:\n\n@@@ \n/*\n** Interpret zArg as an integer value, possibly with suffixes.\n*/\nstatic sqlite3_int64 integerValue(const char *zArg){\n  sqlite3_int64 v = 0;\n  static const struct { char *zSuffix; int iMult; } aMult[] = {\n    { \"KiB\", 1024 },\n    { \"MiB\", 1024*1024 },\n    { \"GiB\", 1024*1024*1024 },\n    { \"KB\",  1000 },\n    { \"MB\",  1000000 },\n    { \"GB\",  1000000000 },\n    { \"K\",   1000 },\n    { \"M\",   1000000 },\n    { \"G\",   1000000000 },\n  };\n  int i;\n  int isNeg = 0;\n\n  /* Handle optional leading '+' or '-' sign */\n  if( zArg[0]=='-' ){\n    isNeg = 1;\n    zArg++;\n  }else if( zArg[0]=='+' ){\n    zArg++;\n  }\n\n  /* Parse the numeric part of zArg (decimal or hex) and store in v */\n  /* ... parsing logic omitted for brevity ... */\n\n  /* Check for suffix and multiply v by corresponding multiplier */\n  for(i=0; i<ArraySize(aMult); i++){\n    if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\n      v *= aMult[i].iMult;  /* Vulnerable multiplication causing possible overflow */\n      break;\n    }\n  }\n\n  /* Return the possibly negated value */\n  return isNeg? -v : v;\n}\n@@@"
  },
  {
    "role": "user",
    "content": "EARLYSTOP: [' \\n/*\\n** Interpret zArg as an integer value, possibly with suffixes.\\n*/\\nstatic sqlite3_int64 integerValue(const char *zArg){\\n  sqlite3_int64 v = 0;\\n  static const struct { char *zSuffix; int iMult; } aMult[] = {\\n    { \"KiB\", 1024 },\\n    { \"MiB\", 1024*1024 },\\n    { \"GiB\", 1024*1024*1024 },\\n    { \"KB\",  1000 },\\n    { \"MB\",  1000000 },\\n    { \"GB\",  1000000000 },\\n    { \"K\",   1000 },\\n    { \"M\",   1000000 },\\n    { \"G\",   1000000000 },\\n  };\\n  int i;\\n  int isNeg = 0;\\n\\n  /* Handle optional leading \\'+\\' or \\'-\\' sign */\\n  if( zArg[0]==\\'-\\' ){\\n    isNeg = 1;\\n    zArg++;\\n  }else if( zArg[0]==\\'+\\' ){\\n    zArg++;\\n  }\\n\\n  /* Parse the numeric part of zArg (decimal or hex) and store in v */\\n  /* ... parsing logic omitted for brevity ... */\\n\\n  /* Check for suffix and multiply v by corresponding multiplier */\\n  for(i=0; i<ArraySize(aMult); i++){\\n    if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n      v *= aMult[i].iMult;  /* Vulnerable multiplication causing possible overflow */\\n      break;\\n    }\\n  }\\n\\n  /* Return the possibly negated value */\\n  return isNeg? -v : v;\\n}\\n', '26076: /*\\n26077: ** Interpret zArg as either an integer or a boolean value.  Return 1 or 0\\n26078: ** for TRUE and FALSE.  Return the integer value if appropriate.\\n26079: */\\n26080: static int booleanValue(const char *zArg){\\n26081:   int i;\\n26082:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n26083:     for(i=2; hexDigitValue(zArg[i])>=0; i++){}\\n26084:   }else{\\n26085:     for(i=0; zArg[i]>=\\'0\\' && zArg[i]<=\\'9\\'; i++){}\\n26086:   }\\n26087:   if( i>0 && zArg[i]==0 ) return (int)(integerValue(zArg) & 0xffffffff);\\n26088:   if( sqlite3_stricmp(zArg, \"on\")==0 || sqlite3_stricmp(zArg,\"yes\")==0 ){\\n26089:     return 1;\\n26090:   }\\n26091:   if( sqlite3_stricmp(zArg, \"off\")==0 || sqlite3_stricmp(zArg,\"no\")==0 ){\\n26092:     return 0;\\n26093:   }\\n26094:   sqlite3_fprintf(stderr,\\n26095:        \"ERROR: Not a boolean value: \\\\\"%s\\\\\". Assuming \\\\\"no\\\\\".\\\\n\", zArg);\\n26096:   return 0;\\n26097: }\\n842: /*\\n843: ** Interpret zArg as a boolean value.  Return either 0 or 1.\\n844: */\\n845: static int booleanValue(char *zArg){\\n846:   int i;\\n847:   if( zArg==0 ) return 0;\\n848:   for(i=0; zArg[i]>=\\'0\\' && zArg[i]<=\\'9\\'; i++){}\\n849:   if( i>0 && zArg[i]==0 ) return atoi(zArg);\\n850:   if( sqlite3_stricmp(zArg, \"on\")==0 || sqlite3_stricmp(zArg,\"yes\")==0 ){\\n851:     return 1;\\n852:   }\\n853:   if( sqlite3_stricmp(zArg, \"off\")==0 || sqlite3_stricmp(zArg,\"no\")==0 ){\\n854:     return 0;\\n855:   }\\n856:   errorMessage(\"unknown boolean: [%s]\", zArg);\\n857:   return 0;\\n858: }\\n']"
  },
  {
    "role": "assistant",
    "content": "@@@not entry point@@@"
  },
  {
    "role": "user",
    "content": "PRUNE: [' \\n/*\\n** Interpret zArg as an integer value, possibly with suffixes.\\n*/\\nstatic sqlite3_int64 integerValue(const char *zArg){\\n  sqlite3_int64 v = 0;\\n  static const struct { char *zSuffix; int iMult; } aMult[] = {\\n    { \"KiB\", 1024 },\\n    { \"MiB\", 1024*1024 },\\n    { \"GiB\", 1024*1024*1024 },\\n    { \"KB\",  1000 },\\n    { \"MB\",  1000000 },\\n    { \"GB\",  1000000000 },\\n    { \"K\",   1000 },\\n    { \"M\",   1000000 },\\n    { \"G\",   1000000000 },\\n  };\\n  int i;\\n  int isNeg = 0;\\n\\n  /* Handle optional leading \\'+\\' or \\'-\\' sign */\\n  if( zArg[0]==\\'-\\' ){\\n    isNeg = 1;\\n    zArg++;\\n  }else if( zArg[0]==\\'+\\' ){\\n    zArg++;\\n  }\\n\\n  /* Parse the numeric part of zArg (decimal or hex) and store in v */\\n  /* ... parsing logic omitted for brevity ... */\\n\\n  /* Check for suffix and multiply v by corresponding multiplier */\\n  for(i=0; i<ArraySize(aMult); i++){\\n    if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n      v *= aMult[i].iMult;  /* Vulnerable multiplication causing possible overflow */\\n      break;\\n    }\\n  }\\n\\n  /* Return the possibly negated value */\\n  return isNeg? -v : v;\\n}\\n', '26076: /*\\n26077: ** Interpret zArg as either an integer or a boolean value.  Return 1 or 0\\n26078: ** for TRUE and FALSE.  Return the integer value if appropriate.\\n26079: */\\n26080: static int booleanValue(const char *zArg){\\n26081:   int i;\\n26082:   if( zArg[0]==\\'0\\' && zArg[1]==\\'x\\' ){\\n26083:     for(i=2; hexDigitValue(zArg[i])>=0; i++){}\\n26084:   }else{\\n26085:     for(i=0; zArg[i]>=\\'0\\' && zArg[i]<=\\'9\\'; i++){}\\n26086:   }\\n26087:   if( i>0 && zArg[i]==0 ) return (int)(integerValue(zArg) & 0xffffffff);\\n26088:   if( sqlite3_stricmp(zArg, \"on\")==0 || sqlite3_stricmp(zArg,\"yes\")==0 ){\\n26089:     return 1;\\n26090:   }\\n26091:   if( sqlite3_stricmp(zArg, \"off\")==0 || sqlite3_stricmp(zArg,\"no\")==0 ){\\n26092:     return 0;\\n26093:   }\\n26094:   sqlite3_fprintf(stderr,\\n26095:        \"ERROR: Not a boolean value: \\\\\"%s\\\\\". Assuming \\\\\"no\\\\\".\\\\n\", zArg);\\n26096:   return 0;\\n26097: }\\n842: /*\\n843: ** Interpret zArg as a boolean value.  Return either 0 or 1.\\n844: */\\n845: static int booleanValue(char *zArg){\\n846:   int i;\\n847:   if( zArg==0 ) return 0;\\n848:   for(i=0; zArg[i]>=\\'0\\' && zArg[i]<=\\'9\\'; i++){}\\n849:   if( i>0 && zArg[i]==0 ) return atoi(zArg);\\n850:   if( sqlite3_stricmp(zArg, \"on\")==0 || sqlite3_stricmp(zArg,\"yes\")==0 ){\\n851:     return 1;\\n852:   }\\n853:   if( sqlite3_stricmp(zArg, \"off\")==0 || sqlite3_stricmp(zArg,\"no\")==0 ){\\n854:     return 0;\\n855:   }\\n856:   errorMessage(\"unknown boolean: [%s]\", zArg);\\n857:   return 0;\\n858: }\\n']"
  },
  {
    "role": "assistant",
    "content": "Analysis:\nThe vulnerable line `v *= aMult[i].iMult;` performs a signed multiplication on `v` (type `sqlite3_int64`, a 64-bit signed integer) and `aMult[i].iMult` (type `int`, a 32-bit signed integer). There is no explicit range check before multiplication, and the multiplier constants (e.g., 1024*1024*1024 = 1073741824) are large enough that multiplying by them can overflow a 64-bit signed integer if `v` is sufficiently large. The input `zArg` is user-controlled and parsed without shown overflow checks, so `v` can be arbitrarily large before multiplication. No checked arithmetic or wider intermediate type is used. Negation is applied only after multiplication, but no guard against `INT64_MIN` negation is shown. Therefore, signed integer overflow is possible on this path.\n\n@@@may vulnerability@@@"
  },
  {
    "role": "user",
    "content": "EARLYSTOP: [' \\n/*\\n** Interpret zArg as an integer value, possibly with suffixes.\\n*/\\nstatic sqlite3_int64 integerValue(const char *zArg){\\n  sqlite3_int64 v = 0;\\n  static const struct { char *zSuffix; int iMult; } aMult[] = {\\n    { \"KiB\", 1024 },\\n    { \"MiB\", 1024*1024 },\\n    { \"GiB\", 1024*1024*1024 },\\n    { \"KB\",  1000 },\\n    { \"MB\",  1000000 },\\n    { \"GB\",  1000000000 },\\n    { \"K\",   1000 },\\n    { \"M\",   1000000 },\\n    { \"G\",   1000000000 },\\n  };\\n  int i;\\n  int isNeg = 0;\\n\\n  /* Handle optional leading \\'+\\' or \\'-\\' sign */\\n  if( zArg[0]==\\'-\\' ){\\n    isNeg = 1;\\n    zArg++;\\n  }else if( zArg[0]==\\'+\\' ){\\n    zArg++;\\n  }\\n\\n  /* Parse the numeric part of zArg (decimal or hex) and store in v */\\n  /* ... parsing logic omitted for brevity ... */\\n\\n  /* Check for suffix and multiply v by corresponding multiplier */\\n  for(i=0; i<ArraySize(aMult); i++){\\n    if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){\\n      v *= aMult[i].iMult;  /* Vulnerable multiplication causing possible overflow */\\n      break;\\n    }\\n  }\\n\\n  /* Return the possibly negated value */\\n  return isNeg? -v : v;\\n}\\n', '28553: /*\\n28554: ** If an input line begins with \".\" then invoke this routine to\\n28555: ** process that line.\\n28556: **\\n28557: ** Return 1 on error, 2 to exit, and 0 otherwise.\\n28558: */\\n28559: static int do_meta_command(char *zLine, ShellState *p){\\n28560:   int h = 1;\\n28561:   int nArg = 0;\\n28562:   int n, c;\\n28563:   int rc = 0;\\n28564:   char *azArg[52];\\n28565: \\n28566: #ifndef SQLITE_OMIT_VIRTUALTABLE\\n28567:   if( p->expert.pExpert ){\\n28568:     expertFinish(p, 1, 0);\\n28569:   }\\n28570: #endif\\n28571: \\n28572:   /* Parse the input line into tokens.\\n28573:   */\\n28574:   while( zLine[h] && nArg<ArraySize(azArg)-1 ){\\n28575:     while( IsSpace(zLine[h]) ){ h++; }\\n28576:     if( zLine[h]==0 ) break;\\n28577:     if( zLine[h]==\\'\\\\\\'\\' || zLine[h]==\\'\"\\' ){\\n28578:       int delim = zLine[h++];\\n28579:       azArg[nArg++] = &zLine[h];\\n28580:       while( zLine[h] && zLine[h]!=delim ){\\n28581:         if( zLine[h]==\\'\\\\\\\\\\' && delim==\\'\"\\' && zLine[h+1]!=0 ) h++;\\n28582:         h++;\\n28583:       }\\n28584:       if( zLine[h]==delim ){\\n28585:         zLine[h++] = 0;\\n28586:       }\\n28587:       if( delim==\\'\"\\' ) resolve_backslashes(azArg[nArg-1]);\\n28588:     }else{\\n28589:       azArg[nArg++] = &zLine[h];\\n28590:       while( zLine[h] && !IsSpace(zLine[h]) ){ h++; }\\n28591:       if( zLine[h] ) zLine[h++] = 0;\\n28592:     }\\n28593:   }\\n28594:   azArg[nArg] = 0;\\n28595: \\n28596:   /* Process the input line.\\n28597:   */\\n28598:   if( nArg==0 ) return 0; /* no tokens, no error */\\n28599:   n = strlen30(azArg[0]);\\n28600:   c = azArg[0][0];\\n28601:   clearTempFile(p);\\n28602: \\n28603: #ifndef SQLITE_OMIT_AUTHORIZATION\\n28604:   if( c==\\'a\\' && cli_strncmp(azArg[0], \"auth\", n)==0 ){\\n28605:     if( nArg!=2 ){\\n28606:       sqlite3_fprintf(stderr, \"Usage: .auth ON|OFF\\\\n\");\\n28607:       rc = 1;\\n28608:       goto meta_command_exit;\\n28609:     }\\n28610:     open_db(p, 0);\\n28611:     if( booleanValue(azArg[1]) ){\\n28612:       sqlite3_set_authorizer(p->db, shellAuth, p);\\n28613:     }else if( p->bSafeModePersist ){\\n28614:       sqlite3_set_authorizer(p->db, safeModeAuth, p);\\n28615:     }else{\\n28616:       sqlite3_set_authorizer(p->db, 0, 0);\\n28617:     }\\n28618:   }else\\n28619: #endif\\n28620: \\n28621: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB) \\\\\\n28622:   && !defined(SQLITE_SHELL_FIDDLE)\\n28623:   if( c==\\'a\\' && cli_strncmp(azArg[0], \"archive\", n)==0 ){\\n28624:     open_db(p, 0);\\n28625:     failIfSafeMode(p, \"cannot run .archive in safe mode\");\\n28626:     rc = arDotCommand(p, 0, azArg, nArg);\\n28627:   }else\\n28628: #endif\\n28629: \\n28630: #ifndef SQLITE_SHELL_FIDDLE\\n28631:   if( (c==\\'b\\' && n>=3 && cli_strncmp(azArg[0], \"backup\", n)==0)\\n28632:    || (c==\\'s\\' && n>=3 && cli_strncmp(azArg[0], \"save\", n)==0)\\n28633:   ){\\n28634:     const char *zDestFile = 0;\\n28635:     const char *zDb = 0;\\n28636:     sqlite3 *pDest;\\n28637:     sqlite3_backup *pBackup;\\n28638:     int j;\\n28639:     int bAsync = 0;\\n28640:     const char *zVfs = 0;\\n28641:     failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\\n28642:     for(j=1; j<nArg; j++){\\n28643:       const char *z = azArg[j];\\n28644:       if( z[0]==\\'-\\' ){\\n28645:         if( z[1]==\\'-\\' ) z++;\\n28646:         if( cli_strcmp(z, \"-append\")==0 ){\\n28647:           zVfs = \"apndvfs\";\\n28648:         }else\\n28649:         if( cli_strcmp(z, \"-async\")==0 ){\\n28650:           bAsync = 1;\\n28651:         }else\\n28652:         {\\n28653:           sqlite3_fprintf(stderr,\"unknown option: %s\\\\n\", azArg[j]);\\n28654:           return 1;\\n28655:         }\\n28656:       }else if( zDestFile==0 ){\\n28657:         zDestFile = azArg[j];\\n28658:       }else if( zDb==0 ){\\n28659:         zDb = zDestFile;\\n28660:         zDestFile = azArg[j];\\n28661:       }else{\\n28662:         sqlite3_fprintf(stderr, \"Usage: .backup ?DB? ?OPTIONS? FILENAME\\\\n\");\\n28663:         return 1;\\n28664:       }\\n28665:     }\\n28666:     if( zDestFile==0 ){\\n28667:       sqlite3_fprintf(stderr, \"missing FILENAME argument on .backup\\\\n\");\\n28668:       return 1;\\n28669:     }\\n28670:     if( zDb==0 ) zDb = \"main\";\\n28671:     rc = sqlite3_open_v2(zDestFile, &pDest,\\n28672:                   SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs);\\n28673:     if( rc!=SQLITE_OK ){\\n28674:       sqlite3_fprintf(stderr,\"Error: cannot open \\\\\"%s\\\\\"\\\\n\", zDestFile);\\n28675:       close_db(pDest);\\n28676:       return 1;\\n28677:     }\\n28678:     if( bAsync ){\\n28679:       sqlite3_exec(pDest, \"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\",\\n28680:                    0, 0, 0);\\n28681:     }\\n28682:     open_db(p, 0);\\n28683:     pBackup = sqlite3_backup_init(pDest, \"main\", p->db, zDb);\\n28684:     if( pBackup==0 ){\\n28685:       shellDatabaseError(pDest);\\n28686:       close_db(pDest);\\n28687:       return 1;\\n28688:     }\\n28689:     while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}\\n28690:     sqlite3_backup_finish(pBackup);\\n28691:     if( rc==SQLITE_DONE ){\\n28692:       rc = 0;\\n28693:     }else{\\n28694:       shellDatabaseError(pDest);\\n28695:       rc = 1;\\n28696:     }\\n28697:     close_db(pDest);\\n28698:   }else\\n28699: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n28700: \\n28701:   if( c==\\'b\\' && n>=3 && cli_strncmp(azArg[0], \"bail\", n)==0 ){\\n28702:     if( nArg==2 ){\\n28703:       bail_on_error = booleanValue(azArg[1]);\\n28704:     }else{\\n28705:       eputz(\"Usage: .bail on|off\\\\n\");\\n28706:       rc = 1;\\n28707:     }\\n28708:   }else\\n28709: \\n28710:   /* Undocumented.  Legacy only.  See \"crlf\" below */\\n28711:   if( c==\\'b\\' && n>=3 && cli_strncmp(azArg[0], \"binary\", n)==0 ){\\n28712:     eputz(\"The \\\\\".binary\\\\\" command is deprecated.\\\\n\");\\n28713:     rc = 1;\\n28714:   }else\\n28715: \\n28716:   /* The undocumented \".breakpoint\" command causes a call to the no-op\\n28717:   ** routine named test_breakpoint().\\n28718:   */\\n28719:   if( c==\\'b\\' && n>=3 && cli_strncmp(azArg[0], \"breakpoint\", n)==0 ){\\n28720:     test_breakpoint();\\n28721:   }else\\n28722: \\n28723: #ifndef SQLITE_SHELL_FIDDLE\\n28724:   if( c==\\'c\\' && cli_strcmp(azArg[0],\"cd\")==0 ){\\n28725:     failIfSafeMode(p, \"cannot run .cd in safe mode\");\\n28726:     if( nArg==2 ){\\n28727: #if defined(_WIN32) || defined(WIN32)\\n28728:       wchar_t *z = sqlite3_win32_utf8_to_unicode(azArg[1]);\\n28729:       rc = !SetCurrentDirectoryW(z);\\n28730:       sqlite3_free(z);\\n28731: #else\\n28732:       rc = chdir(azArg[1]);\\n28733: #endif\\n28734:       if( rc ){\\n28735:         sqlite3_fprintf(stderr,\"Cannot change to directory \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n28736:         rc = 1;\\n28737:       }\\n28738:     }else{\\n28739:       eputz(\"Usage: .cd DIRECTORY\\\\n\");\\n28740:       rc = 1;\\n28741:     }\\n28742:   }else\\n28743: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n28744: \\n28745:   if( c==\\'c\\' && n>=3 && cli_strncmp(azArg[0], \"changes\", n)==0 ){\\n28746:     if( nArg==2 ){\\n28747:       setOrClearFlag(p, SHFLG_CountChanges, azArg[1]);\\n28748:     }else{\\n28749:       eputz(\"Usage: .changes on|off\\\\n\");\\n28750:       rc = 1;\\n28751:     }\\n28752:   }else\\n28753: \\n28754: #ifndef SQLITE_SHELL_FIDDLE\\n28755:   /* Cancel output redirection, if it is currently set (by .testcase)\\n28756:   ** Then read the content of the testcase-out.txt file and compare against\\n28757:   ** azArg[1].  If there are differences, report an error and exit.\\n28758:   */\\n28759:   if( c==\\'c\\' && n>=3 && cli_strncmp(azArg[0], \"check\", n)==0 ){\\n28760:     char *zRes = 0;\\n28761:     output_reset(p);\\n28762:     if( nArg!=2 ){\\n28763:       eputz(\"Usage: .check GLOB-PATTERN\\\\n\");\\n28764:       rc = 2;\\n28765:     }else if( (zRes = readFile(\"testcase-out.txt\", 0))==0 ){\\n28766:       rc = 2;\\n28767:     }else if( testcase_glob(azArg[1],zRes)==0 ){\\n28768:       sqlite3_fprintf(stderr,\\n28769:             \"testcase-%s FAILED\\\\n Expected: [%s]\\\\n      Got: [%s]\\\\n\",\\n28770:             p->zTestcase, azArg[1], zRes);\\n28771:       rc = 1;\\n28772:     }else{\\n28773:       sqlite3_fprintf(p->out, \"testcase-%s ok\\\\n\", p->zTestcase);\\n28774:       p->nCheck++;\\n28775:     }\\n28776:     sqlite3_free(zRes);\\n28777:   }else\\n28778: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n28779: \\n28780: #ifndef SQLITE_SHELL_FIDDLE\\n28781:   if( c==\\'c\\' && cli_strncmp(azArg[0], \"clone\", n)==0 ){\\n28782:     failIfSafeMode(p, \"cannot run .clone in safe mode\");\\n28783:     if( nArg==2 ){\\n28784:       tryToClone(p, azArg[1]);\\n28785:     }else{\\n28786:       eputz(\"Usage: .clone FILENAME\\\\n\");\\n28787:       rc = 1;\\n28788:     }\\n28789:   }else\\n28790: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n28791: \\n28792:   if( c==\\'c\\' && cli_strncmp(azArg[0], \"connection\", n)==0 ){\\n28793:     if( nArg==1 ){\\n28794:       /* List available connections */\\n28795:       int i;\\n28796:       for(i=0; i<ArraySize(p->aAuxDb); i++){\\n28797:         const char *zFile = p->aAuxDb[i].zDbFilename;\\n28798:         if( p->aAuxDb[i].db==0 && p->pAuxDb!=&p->aAuxDb[i] ){\\n28799:           zFile = \"(not open)\";\\n28800:         }else if( zFile==0 ){\\n28801:           zFile = \"(memory)\";\\n28802:         }else if( zFile[0]==0 ){\\n28803:           zFile = \"(temporary-file)\";\\n28804:         }\\n28805:         if( p->pAuxDb == &p->aAuxDb[i] ){\\n28806:           sqlite3_fprintf(stdout, \"ACTIVE %d: %s\\\\n\", i, zFile);\\n28807:         }else if( p->aAuxDb[i].db!=0 ){\\n28808:           sqlite3_fprintf(stdout, \"       %d: %s\\\\n\", i, zFile);\\n28809:         }\\n28810:       }\\n28811:     }else if( nArg==2 && IsDigit(azArg[1][0]) && azArg[1][1]==0 ){\\n28812:       int i = azArg[1][0] - \\'0\\';\\n28813:       if( p->pAuxDb != &p->aAuxDb[i] && i>=0 && i<ArraySize(p->aAuxDb) ){\\n28814:         p->pAuxDb->db = p->db;\\n28815:         p->pAuxDb = &p->aAuxDb[i];\\n28816:         globalDb = p->db = p->pAuxDb->db;\\n28817:         p->pAuxDb->db = 0;\\n28818:       }\\n28819:     }else if( nArg==3 && cli_strcmp(azArg[1], \"close\")==0\\n28820:            && IsDigit(azArg[2][0]) && azArg[2][1]==0 ){\\n28821:       int i = azArg[2][0] - \\'0\\';\\n28822:       if( i<0 || i>=ArraySize(p->aAuxDb) ){\\n28823:         /* No-op */\\n28824:       }else if( p->pAuxDb == &p->aAuxDb[i] ){\\n28825:         eputz(\"cannot close the active database connection\\\\n\");\\n28826:         rc = 1;\\n28827:       }else if( p->aAuxDb[i].db ){\\n28828:         session_close_all(p, i);\\n28829:         close_db(p->aAuxDb[i].db);\\n28830:         p->aAuxDb[i].db = 0;\\n28831:       }\\n28832:     }else{\\n28833:       eputz(\"Usage: .connection [close] [CONNECTION-NUMBER]\\\\n\");\\n28834:       rc = 1;\\n28835:     }\\n28836:   }else\\n28837: \\n28838:   if( c==\\'c\\' && n==4\\n28839:    && (cli_strncmp(azArg[0], \"crlf\", n)==0\\n28840:        || cli_strncmp(azArg[0], \"crnl\",n)==0)\\n28841:   ){\\n28842:     if( nArg==2 ){\\n28843: #ifdef _WIN32\\n28844:       p->crlfMode = booleanValue(azArg[1]);\\n28845: #else\\n28846:       p->crlfMode = 0;\\n28847: #endif\\n28848:     }\\n28849:     sqlite3_fprintf(stderr, \"crlf is %s\\\\n\", p->crlfMode ? \"ON\" : \"OFF\");\\n28850:   }else\\n28851: \\n28852:   if( c==\\'d\\' && n>1 && cli_strncmp(azArg[0], \"databases\", n)==0 ){\\n28853:     char **azName = 0;\\n28854:     int nName = 0;\\n28855:     sqlite3_stmt *pStmt;\\n28856:     int i;\\n28857:     open_db(p, 0);\\n28858:     rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\\n28859:     if( rc ){\\n28860:       shellDatabaseError(p->db);\\n28861:       rc = 1;\\n28862:     }else{\\n28863:       while( sqlite3_step(pStmt)==SQLITE_ROW ){\\n28864:         const char *zSchema = (const char *)sqlite3_column_text(pStmt,1);\\n28865:         const char *zFile = (const char*)sqlite3_column_text(pStmt,2);\\n28866:         if( zSchema==0 || zFile==0 ) continue;\\n28867:         azName = sqlite3_realloc(azName, (nName+1)*2*sizeof(char*));\\n28868:         shell_check_oom(azName);\\n28869:         azName[nName*2] = strdup(zSchema);\\n28870:         azName[nName*2+1] = strdup(zFile);\\n28871:         nName++;\\n28872:       }\\n28873:     }\\n28874:     sqlite3_finalize(pStmt);\\n28875:     for(i=0; i<nName; i++){\\n28876:       int eTxn = sqlite3_txn_state(p->db, azName[i*2]);\\n28877:       int bRdonly = sqlite3_db_readonly(p->db, azName[i*2]);\\n28878:       const char *z = azName[i*2+1];\\n28879:       sqlite3_fprintf(p->out, \"%s: %s %s%s\\\\n\",\\n28880:             azName[i*2], z && z[0] ? z : \"\\\\\"\\\\\"\", bRdonly ? \"r/o\" : \"r/w\",\\n28881:             eTxn==SQLITE_TXN_NONE ? \"\" :\\n28882:             eTxn==SQLITE_TXN_READ ? \" read-txn\" : \" write-txn\");\\n28883:       free(azName[i*2]);\\n28884:       free(azName[i*2+1]);\\n28885:     }\\n28886:     sqlite3_free(azName);\\n28887:   }else\\n28888: \\n28889:   if( c==\\'d\\' && n>=3 && cli_strncmp(azArg[0], \"dbconfig\", n)==0 ){\\n28890:     static const struct DbConfigChoices {\\n28891:       const char *zName;\\n28892:       int op;\\n28893:     } aDbConfig[] = {\\n28894:         { \"attach_create\",      SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE  },\\n28895:         { \"attach_write\",       SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE   },\\n28896:         { \"comments\",           SQLITE_DBCONFIG_ENABLE_COMMENTS       },\\n28897:         { \"defensive\",          SQLITE_DBCONFIG_DEFENSIVE             },\\n28898:         { \"dqs_ddl\",            SQLITE_DBCONFIG_DQS_DDL               },\\n28899:         { \"dqs_dml\",            SQLITE_DBCONFIG_DQS_DML               },\\n28900:         { \"enable_fkey\",        SQLITE_DBCONFIG_ENABLE_FKEY           },\\n28901:         { \"enable_qpsg\",        SQLITE_DBCONFIG_ENABLE_QPSG           },\\n28902:         { \"enable_trigger\",     SQLITE_DBCONFIG_ENABLE_TRIGGER        },\\n28903:         { \"enable_view\",        SQLITE_DBCONFIG_ENABLE_VIEW           },\\n28904:         { \"fts3_tokenizer\",     SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER },\\n28905:         { \"legacy_alter_table\", SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    },\\n28906:         { \"legacy_file_format\", SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    },\\n28907:         { \"load_extension\",     SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION },\\n28908:         { \"no_ckpt_on_close\",   SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      },\\n28909:         { \"reset_database\",     SQLITE_DBCONFIG_RESET_DATABASE        },\\n28910:         { \"reverse_scanorder\",  SQLITE_DBCONFIG_REVERSE_SCANORDER     },\\n28911:         { \"stmt_scanstatus\",    SQLITE_DBCONFIG_STMT_SCANSTATUS       },\\n28912:         { \"trigger_eqp\",        SQLITE_DBCONFIG_TRIGGER_EQP           },\\n28913:         { \"trusted_schema\",     SQLITE_DBCONFIG_TRUSTED_SCHEMA        },\\n28914:         { \"writable_schema\",    SQLITE_DBCONFIG_WRITABLE_SCHEMA       },\\n28915:     };\\n28916:     int ii, v;\\n28917:     open_db(p, 0);\\n28918:     for(ii=0; ii<ArraySize(aDbConfig); ii++){\\n28919:       if( nArg>1 && cli_strcmp(azArg[1], aDbConfig[ii].zName)!=0 ) continue;\\n28920:       if( nArg>=3 ){\\n28921:         sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);\\n28922:       }\\n28923:       sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);\\n28924:       sqlite3_fprintf(p->out, \"%19s %s\\\\n\",\\n28925:                       aDbConfig[ii].zName, v ? \"on\" : \"off\");\\n28926:       if( nArg>1 ) break;\\n28927:     }\\n28928:     if( nArg>1 && ii==ArraySize(aDbConfig) ){\\n28929:       sqlite3_fprintf(stderr,\"Error: unknown dbconfig \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n28930:       eputz(\"Enter \\\\\".dbconfig\\\\\" with no arguments for a list\\\\n\");\\n28931:     }\\n28932:   }else\\n28933: \\n28934: #if SQLITE_SHELL_HAVE_RECOVER\\n28935:   if( c==\\'d\\' && n>=3 && cli_strncmp(azArg[0], \"dbinfo\", n)==0 ){\\n28936:     rc = shell_dbinfo_command(p, nArg, azArg);\\n28937:   }else\\n28938: \\n28939:   if( c==\\'r\\' && cli_strncmp(azArg[0], \"recover\", n)==0 ){\\n28940:     open_db(p, 0);\\n28941:     rc = recoverDatabaseCmd(p, nArg, azArg);\\n28942:   }else\\n28943: #endif /* SQLITE_SHELL_HAVE_RECOVER */\\n28944: \\n28945:   if( c==\\'d\\' && cli_strncmp(azArg[0], \"dump\", n)==0 ){\\n28946:     char *zLike = 0;\\n28947:     char *zSql;\\n28948:     int i;\\n28949:     int savedShowHeader = p->showHeader;\\n28950:     int savedShellFlags = p->shellFlgs;\\n28951:     ShellClearFlag(p,\\n28952:        SHFLG_PreserveRowid|SHFLG_Newlines|SHFLG_Echo\\n28953:        |SHFLG_DumpDataOnly|SHFLG_DumpNoSys);\\n28954:     for(i=1; i<nArg; i++){\\n28955:       if( azArg[i][0]==\\'-\\' ){\\n28956:         const char *z = azArg[i]+1;\\n28957:         if( z[0]==\\'-\\' ) z++;\\n28958:         if( cli_strcmp(z,\"preserve-rowids\")==0 ){\\n28959: #ifdef SQLITE_OMIT_VIRTUALTABLE\\n28960:           eputz(\"The --preserve-rowids option is not compatible\"\\n28961:                 \" with SQLITE_OMIT_VIRTUALTABLE\\\\n\");\\n28962:           rc = 1;\\n28963:           sqlite3_free(zLike);\\n28964:           goto meta_command_exit;\\n28965: #else\\n28966:           ShellSetFlag(p, SHFLG_PreserveRowid);\\n28967: #endif\\n28968:         }else\\n28969:         if( cli_strcmp(z,\"newlines\")==0 ){\\n28970:           ShellSetFlag(p, SHFLG_Newlines);\\n28971:         }else\\n28972:         if( cli_strcmp(z,\"data-only\")==0 ){\\n28973:           ShellSetFlag(p, SHFLG_DumpDataOnly);\\n28974:         }else\\n28975:         if( cli_strcmp(z,\"nosys\")==0 ){\\n28976:           ShellSetFlag(p, SHFLG_DumpNoSys);\\n28977:         }else\\n28978:         {\\n28979:           sqlite3_fprintf(stderr,\\n28980:                \"Unknown option \\\\\"%s\\\\\" on \\\\\".dump\\\\\"\\\\n\", azArg[i]);\\n28981:           rc = 1;\\n28982:           sqlite3_free(zLike);\\n28983:           goto meta_command_exit;\\n28984:         }\\n28985:       }else{\\n28986:         /* azArg[i] contains a LIKE pattern. This \".dump\" request should\\n28987:         ** only dump data for tables for which either the table name matches\\n28988:         ** the LIKE pattern, or the table appears to be a shadow table of\\n28989:         ** a virtual table for which the name matches the LIKE pattern.\\n28990:         */\\n28991:         char *zExpr = sqlite3_mprintf(\\n28992:             \"name LIKE %Q ESCAPE \\'\\\\\\\\\\' OR EXISTS (\"\\n28993:             \"  SELECT 1 FROM sqlite_schema WHERE \"\\n28994:             \"    name LIKE %Q ESCAPE \\'\\\\\\\\\\' AND\"\\n28995:             \"    sql LIKE \\'CREATE VIRTUAL TABLE%%\\' AND\"\\n28996:             \"    substr(o.name, 1, length(name)+1) == (name||\\'_\\')\"\\n28997:             \")\", azArg[i], azArg[i]\\n28998:         );\\n28999: \\n29000:         if( zLike ){\\n29001:           zLike = sqlite3_mprintf(\"%z OR %z\", zLike, zExpr);\\n29002:         }else{\\n29003:           zLike = zExpr;\\n29004:         }\\n29005:       }\\n29006:     }\\n29007: \\n29008:     open_db(p, 0);\\n29009: \\n29010:     outputDumpWarning(p, zLike);\\n29011:     if( (p->shellFlgs & SHFLG_DumpDataOnly)==0 ){\\n29012:       /* When playing back a \"dump\", the content might appear in an order\\n29013:       ** which causes immediate foreign key constraints to be violated.\\n29014:       ** So disable foreign-key constraint enforcement to prevent problems. */\\n29015:       sqlite3_fputs(\"PRAGMA foreign_keys=OFF;\\\\n\", p->out);\\n29016:       sqlite3_fputs(\"BEGIN TRANSACTION;\\\\n\", p->out);\\n29017:     }\\n29018:     p->writableSchema = 0;\\n29019:     p->showHeader = 0;\\n29020:     /* Set writable_schema=ON since doing so forces SQLite to initialize\\n29021:     ** as much of the schema as it can even if the sqlite_schema table is\\n29022:     ** corrupt. */\\n29023:     sqlite3_exec(p->db, \"SAVEPOINT dump; PRAGMA writable_schema=ON\", 0, 0, 0);\\n29024:     p->nErr = 0;\\n29025:     if( zLike==0 ) zLike = sqlite3_mprintf(\"true\");\\n29026:     zSql = sqlite3_mprintf(\\n29027:       \"SELECT name, type, sql FROM sqlite_schema AS o \"\\n29028:       \"WHERE (%s) AND type==\\'table\\'\"\\n29029:       \"  AND sql NOT NULL\"\\n29030:       \" ORDER BY tbl_name=\\'sqlite_sequence\\', rowid\",\\n29031:       zLike\\n29032:     );\\n29033:     run_schema_dump_query(p,zSql);\\n29034:     sqlite3_free(zSql);\\n29035:     if( (p->shellFlgs & SHFLG_DumpDataOnly)==0 ){\\n29036:       zSql = sqlite3_mprintf(\\n29037:         \"SELECT sql FROM sqlite_schema AS o \"\\n29038:         \"WHERE (%s) AND sql NOT NULL\"\\n29039:         \"  AND type IN (\\'index\\',\\'trigger\\',\\'view\\') \"\\n29040:         \"ORDER BY type COLLATE NOCASE DESC\",\\n29041:         zLike\\n29042:       );\\n29043:       run_table_dump_query(p, zSql);\\n29044:       sqlite3_free(zSql);\\n29045:     }\\n29046:     sqlite3_free(zLike);\\n29047:     if( p->writableSchema ){\\n29048:       sqlite3_fputs(\"PRAGMA writable_schema=OFF;\\\\n\", p->out);\\n29049:       p->writableSchema = 0;\\n29050:     }\\n29051:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);\\n29052:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);\\n29053:     if( (p->shellFlgs & SHFLG_DumpDataOnly)==0 ){\\n29054:       sqlite3_fputs(p->nErr?\"ROLLBACK; -- due to errors\\\\n\":\"COMMIT;\\\\n\", p->out);\\n29055:     }\\n29056:     p->showHeader = savedShowHeader;\\n29057:     p->shellFlgs = savedShellFlags;\\n29058:   }else\\n29059: \\n29060:   if( c==\\'e\\' && cli_strncmp(azArg[0], \"echo\", n)==0 ){\\n29061:     if( nArg==2 ){\\n29062:       setOrClearFlag(p, SHFLG_Echo, azArg[1]);\\n29063:     }else{\\n29064:       eputz(\"Usage: .echo on|off\\\\n\");\\n29065:       rc = 1;\\n29066:     }\\n29067:   }else\\n29068: \\n29069:   if( c==\\'d\\' && n>=3 && cli_strncmp(azArg[0], \"dbtotxt\", n)==0 ){\\n29070:     rc = shell_dbtotxt_command(p, nArg, azArg);\\n29071:   }else\\n29072: \\n29073:   if( c==\\'e\\' && cli_strncmp(azArg[0], \"eqp\", n)==0 ){\\n29074:     if( nArg==2 ){\\n29075:       p->autoEQPtest = 0;\\n29076:       if( p->autoEQPtrace ){\\n29077:         if( p->db ) sqlite3_exec(p->db, \"PRAGMA vdbe_trace=OFF;\", 0, 0, 0);\\n29078:         p->autoEQPtrace = 0;\\n29079:       }\\n29080:       if( cli_strcmp(azArg[1],\"full\")==0 ){\\n29081:         p->autoEQP = AUTOEQP_full;\\n29082:       }else if( cli_strcmp(azArg[1],\"trigger\")==0 ){\\n29083:         p->autoEQP = AUTOEQP_trigger;\\n29084: #ifdef SQLITE_DEBUG\\n29085:       }else if( cli_strcmp(azArg[1],\"test\")==0 ){\\n29086:         p->autoEQP = AUTOEQP_on;\\n29087:         p->autoEQPtest = 1;\\n29088:       }else if( cli_strcmp(azArg[1],\"trace\")==0 ){\\n29089:         p->autoEQP = AUTOEQP_full;\\n29090:         p->autoEQPtrace = 1;\\n29091:         open_db(p, 0);\\n29092:         sqlite3_exec(p->db, \"SELECT name FROM sqlite_schema LIMIT 1\", 0, 0, 0);\\n29093:         sqlite3_exec(p->db, \"PRAGMA vdbe_trace=ON;\", 0, 0, 0);\\n29094: #endif\\n29095:       }else{\\n29096:         p->autoEQP = (u8)booleanValue(azArg[1]);\\n29097:       }\\n29098:     }else{\\n29099:       eputz(\"Usage: .eqp off|on|trace|trigger|full\\\\n\");\\n29100:       rc = 1;\\n29101:     }\\n29102:   }else\\n29103: \\n29104: #ifndef SQLITE_SHELL_FIDDLE\\n29105:   if( c==\\'e\\' && cli_strncmp(azArg[0], \"exit\", n)==0 ){\\n29106:     if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) exit(rc);\\n29107:     rc = 2;\\n29108:   }else\\n29109: #endif\\n29110: \\n29111:   /* The \".explain\" command is automatic now.  It is largely pointless.  It\\n29112:   ** retained purely for backwards compatibility */\\n29113:   if( c==\\'e\\' && cli_strncmp(azArg[0], \"explain\", n)==0 ){\\n29114:     int val = 1;\\n29115:     if( nArg>=2 ){\\n29116:       if( cli_strcmp(azArg[1],\"auto\")==0 ){\\n29117:         val = 99;\\n29118:       }else{\\n29119:         val =  booleanValue(azArg[1]);\\n29120:       }\\n29121:     }\\n29122:     if( val==1 && p->mode!=MODE_Explain ){\\n29123:       p->normalMode = p->mode;\\n29124:       p->mode = MODE_Explain;\\n29125:       p->autoExplain = 0;\\n29126:     }else if( val==0 ){\\n29127:       if( p->mode==MODE_Explain ) p->mode = p->normalMode;\\n29128:       p->autoExplain = 0;\\n29129:     }else if( val==99 ){\\n29130:       if( p->mode==MODE_Explain ) p->mode = p->normalMode;\\n29131:       p->autoExplain = 1;\\n29132:     }\\n29133:   }else\\n29134: \\n29135: #ifndef SQLITE_OMIT_VIRTUALTABLE\\n29136:   if( c==\\'e\\' && cli_strncmp(azArg[0], \"expert\", n)==0 ){\\n29137:     if( p->bSafeMode ){\\n29138:       sqlite3_fprintf(stderr,\\n29139:             \"Cannot run experimental commands such as \\\\\"%s\\\\\" in safe mode\\\\n\",\\n29140:             azArg[0]);\\n29141:       rc = 1;\\n29142:     }else{\\n29143:       open_db(p, 0);\\n29144:       expertDotCommand(p, azArg, nArg);\\n29145:     }\\n29146:   }else\\n29147: #endif\\n29148: \\n29149:   if( c==\\'f\\' && cli_strncmp(azArg[0], \"filectrl\", n)==0 ){\\n29150:     static const struct {\\n29151:        const char *zCtrlName;   /* Name of a test-control option */\\n29152:        int ctrlCode;            /* Integer code for that option */\\n29153:        const char *zUsage;      /* Usage notes */\\n29154:     } aCtrl[] = {\\n29155:       { \"chunk_size\",     SQLITE_FCNTL_CHUNK_SIZE,      \"SIZE\"           },\\n29156:       { \"data_version\",   SQLITE_FCNTL_DATA_VERSION,    \"\"               },\\n29157:       { \"has_moved\",      SQLITE_FCNTL_HAS_MOVED,       \"\"               },\\n29158:       { \"lock_timeout\",   SQLITE_FCNTL_LOCK_TIMEOUT,    \"MILLISEC\"       },\\n29159:       { \"persist_wal\",    SQLITE_FCNTL_PERSIST_WAL,     \"[BOOLEAN]\"      },\\n29160:    /* { \"pragma\",         SQLITE_FCNTL_PRAGMA,          \"NAME ARG\"       },*/\\n29161:       { \"psow\",       SQLITE_FCNTL_POWERSAFE_OVERWRITE, \"[BOOLEAN]\"      },\\n29162:       { \"reserve_bytes\",  SQLITE_FCNTL_RESERVE_BYTES,   \"[N]\"            },\\n29163:       { \"size_limit\",     SQLITE_FCNTL_SIZE_LIMIT,      \"[LIMIT]\"        },\\n29164:       { \"tempfilename\",   SQLITE_FCNTL_TEMPFILENAME,    \"\"               },\\n29165:    /* { \"win32_av_retry\", SQLITE_FCNTL_WIN32_AV_RETRY,  \"COUNT DELAY\"    },*/\\n29166:     };\\n29167:     int filectrl = -1;\\n29168:     int iCtrl = -1;\\n29169:     sqlite3_int64 iRes = 0;  /* Integer result to display if rc2==1 */\\n29170:     int isOk = 0;            /* 0: usage  1: %lld  2: no-result */\\n29171:     int n2, i;\\n29172:     const char *zCmd = 0;\\n29173:     const char *zSchema = 0;\\n29174: \\n29175:     open_db(p, 0);\\n29176:     zCmd = nArg>=2 ? azArg[1] : \"help\";\\n29177: \\n29178:     if( zCmd[0]==\\'-\\'\\n29179:      && (cli_strcmp(zCmd,\"--schema\")==0 || cli_strcmp(zCmd,\"-schema\")==0)\\n29180:      && nArg>=4\\n29181:     ){\\n29182:       zSchema = azArg[2];\\n29183:       for(i=3; i<nArg; i++) azArg[i-2] = azArg[i];\\n29184:       nArg -= 2;\\n29185:       zCmd = azArg[1];\\n29186:     }\\n29187: \\n29188:     /* The argument can optionally begin with \"-\" or \"--\" */\\n29189:     if( zCmd[0]==\\'-\\' && zCmd[1] ){\\n29190:       zCmd++;\\n29191:       if( zCmd[0]==\\'-\\' && zCmd[1] ) zCmd++;\\n29192:     }\\n29193: \\n29194:     /* --help lists all file-controls */\\n29195:     if( cli_strcmp(zCmd,\"help\")==0 ){\\n29196:       sqlite3_fputs(\"Available file-controls:\\\\n\", p->out);\\n29197:       for(i=0; i<ArraySize(aCtrl); i++){\\n29198:         sqlite3_fprintf(p->out,\\n29199:                \"  .filectrl %s %s\\\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\\n29200:       }\\n29201:       rc = 1;\\n29202:       goto meta_command_exit;\\n29203:     }\\n29204: \\n29205:     /* convert filectrl text option to value. allow any unique prefix\\n29206:     ** of the option name, or a numerical value. */\\n29207:     n2 = strlen30(zCmd);\\n29208:     for(i=0; i<ArraySize(aCtrl); i++){\\n29209:       if( cli_strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 ){\\n29210:         if( filectrl<0 ){\\n29211:           filectrl = aCtrl[i].ctrlCode;\\n29212:           iCtrl = i;\\n29213:         }else{\\n29214:           sqlite3_fprintf(stderr,\"Error: ambiguous file-control: \\\\\"%s\\\\\"\\\\n\"\\n29215:                 \"Use \\\\\".filectrl --help\\\\\" for help\\\\n\", zCmd);\\n29216:           rc = 1;\\n29217:           goto meta_command_exit;\\n29218:         }\\n29219:       }\\n29220:     }\\n29221:     if( filectrl<0 ){\\n29222:       sqlite3_fprintf(stderr,\"Error: unknown file-control: %s\\\\n\"\\n29223:             \"Use \\\\\".filectrl --help\\\\\" for help\\\\n\", zCmd);\\n29224:     }else{\\n29225:       switch(filectrl){\\n29226:         case SQLITE_FCNTL_SIZE_LIMIT: {\\n29227:           if( nArg!=2 && nArg!=3 ) break;\\n29228:           iRes = nArg==3 ? integerValue(azArg[2]) : -1;\\n29229:           sqlite3_file_control(p->db, zSchema, SQLITE_FCNTL_SIZE_LIMIT, &iRes);\\n29230:           isOk = 1;\\n29231:           break;\\n29232:         }\\n29233:         case SQLITE_FCNTL_LOCK_TIMEOUT:\\n29234:         case SQLITE_FCNTL_CHUNK_SIZE: {\\n29235:           int x;\\n29236:           if( nArg!=3 ) break;\\n29237:           x = (int)integerValue(azArg[2]);\\n29238:           sqlite3_file_control(p->db, zSchema, filectrl, &x);\\n29239:           isOk = 2;\\n29240:           break;\\n29241:         }\\n29242:         case SQLITE_FCNTL_PERSIST_WAL:\\n29243:         case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {\\n29244:           int x;\\n29245:           if( nArg!=2 && nArg!=3 ) break;\\n29246:           x = nArg==3 ? booleanValue(azArg[2]) : -1;\\n29247:           sqlite3_file_control(p->db, zSchema, filectrl, &x);\\n29248:           iRes = x;\\n29249:           isOk = 1;\\n29250:           break;\\n29251:         }\\n29252:         case SQLITE_FCNTL_DATA_VERSION:\\n29253:         case SQLITE_FCNTL_HAS_MOVED: {\\n29254:           int x;\\n29255:           if( nArg!=2 ) break;\\n29256:           sqlite3_file_control(p->db, zSchema, filectrl, &x);\\n29257:           iRes = x;\\n29258:           isOk = 1;\\n29259:           break;\\n29260:         }\\n29261:         case SQLITE_FCNTL_TEMPFILENAME: {\\n29262:           char *z = 0;\\n29263:           if( nArg!=2 ) break;\\n29264:           sqlite3_file_control(p->db, zSchema, filectrl, &z);\\n29265:           if( z ){\\n29266:             sqlite3_fprintf(p->out, \"%s\\\\n\", z);\\n29267:             sqlite3_free(z);\\n29268:           }\\n29269:           isOk = 2;\\n29270:           break;\\n29271:         }\\n29272:         case SQLITE_FCNTL_RESERVE_BYTES: {\\n29273:           int x;\\n29274:           if( nArg>=3 ){\\n29275:             x = atoi(azArg[2]);\\n29276:             sqlite3_file_control(p->db, zSchema, filectrl, &x);\\n29277:           }\\n29278:           x = -1;\\n29279:           sqlite3_file_control(p->db, zSchema, filectrl, &x);\\n29280:           sqlite3_fprintf(p->out, \"%d\\\\n\", x);\\n29281:           isOk = 2;\\n29282:           break;\\n29283:         }\\n29284:       }\\n29285:     }\\n29286:     if( isOk==0 && iCtrl>=0 ){\\n29287:       sqlite3_fprintf(p->out, \"Usage: .filectrl %s %s\\\\n\",\\n29288:                       zCmd, aCtrl[iCtrl].zUsage);\\n29289:       rc = 1;\\n29290:     }else if( isOk==1 ){\\n29291:       char zBuf[100];\\n29292:       sqlite3_snprintf(sizeof(zBuf), zBuf, \"%lld\", iRes);\\n29293:       sqlite3_fprintf(p->out, \"%s\\\\n\", zBuf);\\n29294:     }\\n29295:   }else\\n29296: \\n29297:   if( c==\\'f\\' && cli_strncmp(azArg[0], \"fullschema\", n)==0 ){\\n29298:     ShellState data;\\n29299:     int doStats = 0;\\n29300:     memcpy(&data, p, sizeof(data));\\n29301:     data.showHeader = 0;\\n29302:     data.cMode = data.mode = MODE_Semi;\\n29303:     if( nArg==2 && optionMatch(azArg[1], \"indent\") ){\\n29304:       data.cMode = data.mode = MODE_Pretty;\\n29305:       nArg = 1;\\n29306:     }\\n29307:     if( nArg!=1 ){\\n29308:       eputz(\"Usage: .fullschema ?--indent?\\\\n\");\\n29309:       rc = 1;\\n29310:       goto meta_command_exit;\\n29311:     }\\n29312:     open_db(p, 0);\\n29313:     rc = sqlite3_exec(p->db,\\n29314:        \"SELECT sql FROM\"\\n29315:        \"  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x\"\\n29316:        \"     FROM sqlite_schema UNION ALL\"\\n29317:        \"   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) \"\\n29318:        \"WHERE type!=\\'meta\\' AND sql NOTNULL AND name NOT LIKE \\'sqlite_%\\' \"\\n29319:        \"ORDER BY x\",\\n29320:        callback, &data, 0\\n29321:     );\\n29322:     if( rc==SQLITE_OK ){\\n29323:       sqlite3_stmt *pStmt;\\n29324:       rc = sqlite3_prepare_v2(p->db,\\n29325:                \"SELECT rowid FROM sqlite_schema\"\\n29326:                \" WHERE name GLOB \\'sqlite_stat[134]\\'\",\\n29327:                -1, &pStmt, 0);\\n29328:       if( rc==SQLITE_OK ){\\n29329:         doStats = sqlite3_step(pStmt)==SQLITE_ROW;\\n29330:         sqlite3_finalize(pStmt);\\n29331:       }\\n29332:     }\\n29333:     if( doStats==0 ){\\n29334:       sqlite3_fputs(\"/* No STAT tables available */\\\\n\", p->out);\\n29335:     }else{\\n29336:       sqlite3_fputs(\"ANALYZE sqlite_schema;\\\\n\", p->out);\\n29337:       data.cMode = data.mode = MODE_Insert;\\n29338:       data.zDestTable = \"sqlite_stat1\";\\n29339:       shell_exec(&data, \"SELECT * FROM sqlite_stat1\", 0);\\n29340:       data.zDestTable = \"sqlite_stat4\";\\n29341:       shell_exec(&data, \"SELECT * FROM sqlite_stat4\", 0);\\n29342:       sqlite3_fputs(\"ANALYZE sqlite_schema;\\\\n\", p->out);\\n29343:     }\\n29344:   }else\\n29345: \\n29346:   if( c==\\'h\\' && cli_strncmp(azArg[0], \"headers\", n)==0 ){\\n29347:     if( nArg==2 ){\\n29348:       p->showHeader = booleanValue(azArg[1]);\\n29349:       p->shellFlgs |= SHFLG_HeaderSet;\\n29350:     }else{\\n29351:       eputz(\"Usage: .headers on|off\\\\n\");\\n29352:       rc = 1;\\n29353:     }\\n29354:   }else\\n29355: \\n29356:   if( c==\\'h\\' && cli_strncmp(azArg[0], \"help\", n)==0 ){\\n29357:     if( nArg>=2 ){\\n29358:       n = showHelp(p->out, azArg[1]);\\n29359:       if( n==0 ){\\n29360:         sqlite3_fprintf(p->out, \"Nothing matches \\'%s\\'\\\\n\", azArg[1]);\\n29361:       }\\n29362:     }else{\\n29363:       showHelp(p->out, 0);\\n29364:     }\\n29365:   }else\\n29366: \\n29367: #ifndef SQLITE_SHELL_FIDDLE\\n29368:   if( c==\\'i\\' && cli_strncmp(azArg[0], \"import\", n)==0 ){\\n29369:     char *zTable = 0;           /* Insert data into this table */\\n29370:     char *zSchema = 0;          /* Schema of zTable */\\n29371:     char *zFile = 0;            /* Name of file to extra content from */\\n29372:     sqlite3_stmt *pStmt = NULL; /* A statement */\\n29373:     int nCol;                   /* Number of columns in the table */\\n29374:     i64 nByte;                  /* Number of bytes in an SQL string */\\n29375:     int i, j;                   /* Loop counters */\\n29376:     int needCommit;             /* True to COMMIT or ROLLBACK at end */\\n29377:     int nSep;                   /* Number of bytes in p->colSeparator[] */\\n29378:     char *zSql = 0;             /* An SQL statement */\\n29379:     ImportCtx sCtx;             /* Reader context */\\n29380:     char *(SQLITE_CDECL *xRead)(ImportCtx*); /* Func to read one value */\\n29381:     int eVerbose = 0;           /* Larger for more console output */\\n29382:     int nSkip = 0;              /* Initial lines to skip */\\n29383:     int useOutputMode = 1;      /* Use output mode to determine separators */\\n29384:     char *zCreate = 0;          /* CREATE TABLE statement text */\\n29385: \\n29386:     failIfSafeMode(p, \"cannot run .import in safe mode\");\\n29387:     memset(&sCtx, 0, sizeof(sCtx));\\n29388:     if( p->mode==MODE_Ascii ){\\n29389:       xRead = ascii_read_one_field;\\n29390:     }else{\\n29391:       xRead = csv_read_one_field;\\n29392:     }\\n29393:     rc = 1;\\n29394:     for(i=1; i<nArg; i++){\\n29395:       char *z = azArg[i];\\n29396:       if( z[0]==\\'-\\' && z[1]==\\'-\\' ) z++;\\n29397:       if( z[0]!=\\'-\\' ){\\n29398:         if( zFile==0 ){\\n29399:           zFile = z;\\n29400:         }else if( zTable==0 ){\\n29401:           zTable = z;\\n29402:         }else{\\n29403:           sqlite3_fprintf(p->out, \"ERROR: extra argument: \\\\\"%s\\\\\". Usage:\\\\n\",z);\\n29404:           showHelp(p->out, \"import\");\\n29405:           goto meta_command_exit;\\n29406:         }\\n29407:       }else if( cli_strcmp(z,\"-v\")==0 ){\\n29408:         eVerbose++;\\n29409:       }else if( cli_strcmp(z,\"-schema\")==0 && i<nArg-1 ){\\n29410:         zSchema = azArg[++i];\\n29411:       }else if( cli_strcmp(z,\"-skip\")==0 && i<nArg-1 ){\\n29412:         nSkip = integerValue(azArg[++i]);\\n29413:       }else if( cli_strcmp(z,\"-ascii\")==0 ){\\n29414:         sCtx.cColSep = SEP_Unit[0];\\n29415:         sCtx.cRowSep = SEP_Record[0];\\n29416:         xRead = ascii_read_one_field;\\n29417:         useOutputMode = 0;\\n29418:       }else if( cli_strcmp(z,\"-csv\")==0 ){\\n29419:         sCtx.cColSep = \\',\\';\\n29420:         sCtx.cRowSep = \\'\\\\n\\';\\n29421:         xRead = csv_read_one_field;\\n29422:         useOutputMode = 0;\\n29423:       }else{\\n29424:         sqlite3_fprintf(p->out, \"ERROR: unknown option: \\\\\"%s\\\\\".  Usage:\\\\n\", z);\\n29425:         showHelp(p->out, \"import\");\\n29426:         goto meta_command_exit;\\n29427:       }\\n29428:     }\\n29429:     if( zTable==0 ){\\n29430:       sqlite3_fprintf(p->out, \"ERROR: missing %s argument. Usage:\\\\n\",\\n29431:             zFile==0 ? \"FILE\" : \"TABLE\");\\n29432:       showHelp(p->out, \"import\");\\n29433:       goto meta_command_exit;\\n29434:     }\\n29435:     seenInterrupt = 0;\\n29436:     open_db(p, 0);\\n29437:     if( useOutputMode ){\\n29438:       /* If neither the --csv or --ascii options are specified, then set\\n29439:       ** the column and row separator characters from the output mode. */\\n29440:       nSep = strlen30(p->colSeparator);\\n29441:       if( nSep==0 ){\\n29442:         eputz(\"Error: non-null column separator required for import\\\\n\");\\n29443:         goto meta_command_exit;\\n29444:       }\\n29445:       if( nSep>1 ){\\n29446:         eputz(\"Error: multi-character column separators not allowed\"\\n29447:               \" for import\\\\n\");\\n29448:         goto meta_command_exit;\\n29449:       }\\n29450:       nSep = strlen30(p->rowSeparator);\\n29451:       if( nSep==0 ){\\n29452:         eputz(\"Error: non-null row separator required for import\\\\n\");\\n29453:         goto meta_command_exit;\\n29454:       }\\n29455:       if( nSep==2 && p->mode==MODE_Csv\\n29456:        && cli_strcmp(p->rowSeparator,SEP_CrLf)==0\\n29457:       ){\\n29458:         /* When importing CSV (only), if the row separator is set to the\\n29459:         ** default output row separator, change it to the default input\\n29460:         ** row separator.  This avoids having to maintain different input\\n29461:         ** and output row separators. */\\n29462:         sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\\n29463:         nSep = strlen30(p->rowSeparator);\\n29464:       }\\n29465:       if( nSep>1 ){\\n29466:         eputz(\"Error: multi-character row separators not allowed\"\\n29467:               \" for import\\\\n\");\\n29468:         goto meta_command_exit;\\n29469:       }\\n29470:       sCtx.cColSep = (u8)p->colSeparator[0];\\n29471:       sCtx.cRowSep = (u8)p->rowSeparator[0];\\n29472:     }\\n29473:     sCtx.zFile = zFile;\\n29474:     sCtx.nLine = 1;\\n29475:     if( sCtx.zFile[0]==\\'|\\' ){\\n29476: #ifdef SQLITE_OMIT_POPEN\\n29477:       eputz(\"Error: pipes are not supported in this OS\\\\n\");\\n29478:       goto meta_command_exit;\\n29479: #else\\n29480:       sCtx.in = sqlite3_popen(sCtx.zFile+1, \"r\");\\n29481:       sCtx.zFile = \"<pipe>\";\\n29482:       sCtx.xCloser = pclose;\\n29483: #endif\\n29484:     }else{\\n29485:       sCtx.in = sqlite3_fopen(sCtx.zFile, \"rb\");\\n29486:       sCtx.xCloser = fclose;\\n29487:     }\\n29488:     if( sCtx.in==0 ){\\n29489:       sqlite3_fprintf(stderr,\"Error: cannot open \\\\\"%s\\\\\"\\\\n\", zFile);\\n29490:       goto meta_command_exit;\\n29491:     }\\n29492:     if( eVerbose>=2 || (eVerbose>=1 && useOutputMode) ){\\n29493:       char zSep[2];\\n29494:       zSep[1] = 0;\\n29495:       zSep[0] = sCtx.cColSep;\\n29496:       sqlite3_fputs(\"Column separator \", p->out);\\n29497:       output_c_string(p->out, zSep);\\n29498:       sqlite3_fputs(\", row separator \", p->out);\\n29499:       zSep[0] = sCtx.cRowSep;\\n29500:       output_c_string(p->out, zSep);\\n29501:       sqlite3_fputs(\"\\\\n\", p->out);\\n29502:     }\\n29503:     sCtx.z = sqlite3_malloc64(120);\\n29504:     if( sCtx.z==0 ){\\n29505:       import_cleanup(&sCtx);\\n29506:       shell_out_of_memory();\\n29507:     }\\n29508:     /* Below, resources must be freed before exit. */\\n29509:     while( (nSkip--)>0 ){\\n29510:       while( xRead(&sCtx) && sCtx.cTerm==sCtx.cColSep ){}\\n29511:     }\\n29512:     import_append_char(&sCtx, 0);    /* To ensure sCtx.z is allocated */\\n29513:     if( sqlite3_table_column_metadata(p->db, zSchema, zTable,0,0,0,0,0,0) \\n29514:      && 0==db_int(p->db, \"SELECT count(*) FROM \\\\\"%w\\\\\".sqlite_schema\"\\n29515:                          \" WHERE name=%Q AND type=\\'view\\'\",\\n29516:                          zSchema ? zSchema : \"main\", zTable)\\n29517:     ){\\n29518:       /* Table does not exist.  Create it. */\\n29519:       sqlite3 *dbCols = 0;\\n29520:       char *zRenames = 0;\\n29521:       char *zColDefs;\\n29522:       zCreate = sqlite3_mprintf(\"CREATE TABLE \\\\\"%w\\\\\".\\\\\"%w\\\\\"\", \\n29523:                     zSchema ? zSchema : \"main\", zTable);\\n29524:       while( xRead(&sCtx) ){\\n29525:         zAutoColumn(sCtx.z, &dbCols, 0);\\n29526:         if( sCtx.cTerm!=sCtx.cColSep ) break;\\n29527:       }\\n29528:       zColDefs = zAutoColumn(0, &dbCols, &zRenames);\\n29529:       if( zRenames!=0 ){\\n29530:         sqlite3_fprintf((stdin_is_interactive && p->in==stdin)? p->out : stderr,\\n29531:               \"Columns renamed during .import %s due to duplicates:\\\\n\"\\n29532:               \"%s\\\\n\", sCtx.zFile, zRenames);\\n29533:         sqlite3_free(zRenames);\\n29534:       }\\n29535:       assert(dbCols==0);\\n29536:       if( zColDefs==0 ){\\n29537:         sqlite3_fprintf(stderr,\"%s: empty file\\\\n\", sCtx.zFile);\\n29538:         import_cleanup(&sCtx);\\n29539:         rc = 1;\\n29540:         sqlite3_free(zCreate);\\n29541:         goto meta_command_exit;\\n29542:       }\\n29543:       zCreate = sqlite3_mprintf(\"%z%z\\\\n\", zCreate, zColDefs);\\n29544:       if( zCreate==0 ){\\n29545:         import_cleanup(&sCtx);\\n29546:         shell_out_of_memory();\\n29547:       }\\n29548:       if( eVerbose>=1 ){\\n29549:         sqlite3_fprintf(p->out, \"%s\\\\n\", zCreate);\\n29550:       }\\n29551:       rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);\\n29552:       if( rc ){\\n29553:         sqlite3_fprintf(stderr,\\n29554:              \"%s failed:\\\\n%s\\\\n\", zCreate, sqlite3_errmsg(p->db));\\n29555:       }\\n29556:       sqlite3_free(zCreate);\\n29557:       zCreate = 0;\\n29558:       if( rc ){\\n29559:         import_cleanup(&sCtx);\\n29560:         rc = 1;\\n29561:         goto meta_command_exit;\\n29562:       }\\n29563:     }\\n29564:     zSql = sqlite3_mprintf(\"SELECT count(*) FROM pragma_table_info(%Q,%Q);\",\\n29565:                            zTable, zSchema);\\n29566:     if( zSql==0 ){\\n29567:       import_cleanup(&sCtx);\\n29568:       shell_out_of_memory();\\n29569:     }\\n29570:     rc =  sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n29571:     sqlite3_free(zSql);\\n29572:     zSql = 0;\\n29573:     if( rc ){\\n29574:       if (pStmt) sqlite3_finalize(pStmt);\\n29575:       shellDatabaseError(p->db);\\n29576:       import_cleanup(&sCtx);\\n29577:       rc = 1;\\n29578:       goto meta_command_exit;\\n29579:     }\\n29580:     if( sqlite3_step(pStmt)==SQLITE_ROW ){\\n29581:       nCol = sqlite3_column_int(pStmt, 0);\\n29582:     }else{\\n29583:       nCol = 0;\\n29584:     }\\n29585:     sqlite3_finalize(pStmt);\\n29586:     pStmt = 0;\\n29587:     if( nCol==0 ) return 0; /* no columns, no error */\\n29588: \\n29589:     nByte = 64                 /* space for \"INSERT INTO\", \"VALUES(\", \")\\\\0\" */\\n29590:           + (zSchema ? strlen(zSchema)*2 + 2: 0)  /* Quoted schema name */\\n29591:           + strlen(zTable)*2 + 2                  /* Quoted table name */\\n29592:           + nCol*2;            /* Space for \",?\" for each column */\\n29593:     zSql = sqlite3_malloc64( nByte );\\n29594:     if( zSql==0 ){\\n29595:       import_cleanup(&sCtx);\\n29596:       shell_out_of_memory();\\n29597:     }\\n29598:     if( zSchema ){\\n29599:       sqlite3_snprintf(nByte, zSql, \"INSERT INTO \\\\\"%w\\\\\".\\\\\"%w\\\\\" VALUES(?\", \\n29600:                        zSchema, zTable);\\n29601:     }else{\\n29602:       sqlite3_snprintf(nByte, zSql, \"INSERT INTO \\\\\"%w\\\\\" VALUES(?\", zTable);\\n29603:     }\\n29604:     j = strlen30(zSql);\\n29605:     for(i=1; i<nCol; i++){\\n29606:       zSql[j++] = \\',\\';\\n29607:       zSql[j++] = \\'?\\';\\n29608:     }\\n29609:     zSql[j++] = \\')\\';\\n29610:     zSql[j] = 0;\\n29611:     assert( j<nByte );\\n29612:     if( eVerbose>=2 ){\\n29613:       sqlite3_fprintf(p->out, \"Insert using: %s\\\\n\", zSql);\\n29614:     }\\n29615:     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n29616:     sqlite3_free(zSql);\\n29617:     zSql = 0;\\n29618:     if( rc ){\\n29619:       shellDatabaseError(p->db);\\n29620:       if (pStmt) sqlite3_finalize(pStmt);\\n29621:       import_cleanup(&sCtx);\\n29622:       rc = 1;\\n29623:       goto meta_command_exit;\\n29624:     }\\n29625:     needCommit = sqlite3_get_autocommit(p->db);\\n29626:     if( needCommit ) sqlite3_exec(p->db, \"BEGIN\", 0, 0, 0);\\n29627:     do{\\n29628:       int startLine = sCtx.nLine;\\n29629:       for(i=0; i<nCol; i++){\\n29630:         char *z = xRead(&sCtx);\\n29631:         /*\\n29632:         ** Did we reach end-of-file before finding any columns?\\n29633:         ** If so, stop instead of NULL filling the remaining columns.\\n29634:         */\\n29635:         if( z==0 && i==0 ) break;\\n29636:         /*\\n29637:         ** Did we reach end-of-file OR end-of-line before finding any\\n29638:         ** columns in ASCII mode?  If so, stop instead of NULL filling\\n29639:         ** the remaining columns.\\n29640:         */\\n29641:         if( p->mode==MODE_Ascii && (z==0 || z[0]==0) && i==0 ) break;\\n29642:         /*\\n29643:         ** For CSV mode, per RFC 4180, accept EOF in lieu of final\\n29644:         ** record terminator but only for last field of multi-field row.\\n29645:         ** (If there are too few fields, it\\'s not valid CSV anyway.)\\n29646:         */\\n29647:         if( z==0 && (xRead==csv_read_one_field) && i==nCol-1 && i>0 ){\\n29648:           z = \"\";\\n29649:         }\\n29650:         sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);\\n29651:         if( i<nCol-1 && sCtx.cTerm!=sCtx.cColSep ){\\n29652:           sqlite3_fprintf(stderr,\"%s:%d: expected %d columns but found %d\"\\n29653:                 \" - filling the rest with NULL\\\\n\",\\n29654:                 sCtx.zFile, startLine, nCol, i+1);\\n29655:           i += 2;\\n29656:           while( i<=nCol ){ sqlite3_bind_null(pStmt, i); i++; }\\n29657:         }\\n29658:       }\\n29659:       if( sCtx.cTerm==sCtx.cColSep ){\\n29660:         do{\\n29661:           xRead(&sCtx);\\n29662:           i++;\\n29663:         }while( sCtx.cTerm==sCtx.cColSep );\\n29664:         sqlite3_fprintf(stderr,\\n29665:               \"%s:%d: expected %d columns but found %d - extras ignored\\\\n\",\\n29666:               sCtx.zFile, startLine, nCol, i);\\n29667:       }\\n29668:       if( i>=nCol ){\\n29669:         sqlite3_step(pStmt);\\n29670:         rc = sqlite3_reset(pStmt);\\n29671:         if( rc!=SQLITE_OK ){\\n29672:           sqlite3_fprintf(stderr,\"%s:%d: INSERT failed: %s\\\\n\",\\n29673:                 sCtx.zFile, startLine, sqlite3_errmsg(p->db));\\n29674:           sCtx.nErr++;\\n29675:         }else{\\n29676:           sCtx.nRow++;\\n29677:         }\\n29678:       }\\n29679:     }while( sCtx.cTerm!=EOF );\\n29680: \\n29681:     import_cleanup(&sCtx);\\n29682:     sqlite3_finalize(pStmt);\\n29683:     if( needCommit ) sqlite3_exec(p->db, \"COMMIT\", 0, 0, 0);\\n29684:     if( eVerbose>0 ){\\n29685:       sqlite3_fprintf(p->out,\\n29686:             \"Added %d rows with %d errors using %d lines of input\\\\n\",\\n29687:             sCtx.nRow, sCtx.nErr, sCtx.nLine-1);\\n29688:     }\\n29689:   }else\\n29690: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n29691: \\n29692: #ifndef SQLITE_UNTESTABLE\\n29693:   if( c==\\'i\\' && cli_strncmp(azArg[0], \"imposter\", n)==0 ){\\n29694:     char *zSql;\\n29695:     char *zCollist = 0;\\n29696:     sqlite3_stmt *pStmt;\\n29697:     int tnum = 0;\\n29698:     int isWO = 0;  /* True if making an imposter of a WITHOUT ROWID table */\\n29699:     int lenPK = 0; /* Length of the PRIMARY KEY string for isWO tables */\\n29700:     int i;\\n29701:     if( !ShellHasFlag(p,SHFLG_TestingMode) ){\\n29702:       sqlite3_fprintf(stderr,\".%s unavailable without --unsafe-testing\\\\n\",\\n29703:             \"imposter\");\\n29704:       rc = 1;\\n29705:       goto meta_command_exit;\\n29706:     }\\n29707:     if( !(nArg==3 || (nArg==2 && sqlite3_stricmp(azArg[1],\"off\")==0)) ){\\n29708:       eputz(\"Usage: .imposter INDEX IMPOSTER\\\\n\"\\n29709:             \"       .imposter off\\\\n\");\\n29710:       /* Also allowed, but not documented:\\n29711:       **\\n29712:       **    .imposter TABLE IMPOSTER\\n29713:       **\\n29714:       ** where TABLE is a WITHOUT ROWID table.  In that case, the\\n29715:       ** imposter is another WITHOUT ROWID table with the columns in\\n29716:       ** storage order. */\\n29717:       rc = 1;\\n29718:       goto meta_command_exit;\\n29719:     }\\n29720:     open_db(p, 0);\\n29721:     if( nArg==2 ){\\n29722:       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, \"main\", 0, 1);\\n29723:       goto meta_command_exit;\\n29724:     }\\n29725:     zSql = sqlite3_mprintf(\\n29726:       \"SELECT rootpage, 0 FROM sqlite_schema\"\\n29727:       \" WHERE name=\\'%q\\' AND type=\\'index\\'\"\\n29728:       \"UNION ALL \"\\n29729:       \"SELECT rootpage, 1 FROM sqlite_schema\"\\n29730:       \" WHERE name=\\'%q\\' AND type=\\'table\\'\"\\n29731:       \"   AND sql LIKE \\'%%without%%rowid%%\\'\",\\n29732:       azArg[1], azArg[1]\\n29733:     );\\n29734:     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n29735:     sqlite3_free(zSql);\\n29736:     if( sqlite3_step(pStmt)==SQLITE_ROW ){\\n29737:       tnum = sqlite3_column_int(pStmt, 0);\\n29738:       isWO = sqlite3_column_int(pStmt, 1);\\n29739:     }\\n29740:     sqlite3_finalize(pStmt);\\n29741:     zSql = sqlite3_mprintf(\"PRAGMA index_xinfo=\\'%q\\'\", azArg[1]);\\n29742:     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n29743:     sqlite3_free(zSql);\\n29744:     i = 0;\\n29745:     while( rc==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){\\n29746:       char zLabel[20];\\n29747:       const char *zCol = (const char*)sqlite3_column_text(pStmt,2);\\n29748:       i++;\\n29749:       if( zCol==0 ){\\n29750:         if( sqlite3_column_int(pStmt,1)==-1 ){\\n29751:           zCol = \"_ROWID_\";\\n29752:         }else{\\n29753:           sqlite3_snprintf(sizeof(zLabel),zLabel,\"expr%d\",i);\\n29754:           zCol = zLabel;\\n29755:         }\\n29756:       }\\n29757:       if( isWO && lenPK==0 && sqlite3_column_int(pStmt,5)==0 && zCollist ){\\n29758:         lenPK = (int)strlen(zCollist);\\n29759:       }\\n29760:       if( zCollist==0 ){\\n29761:         zCollist = sqlite3_mprintf(\"\\\\\"%w\\\\\"\", zCol);\\n29762:       }else{\\n29763:         zCollist = sqlite3_mprintf(\"%z,\\\\\"%w\\\\\"\", zCollist, zCol);\\n29764:       }\\n29765:     }\\n29766:     sqlite3_finalize(pStmt);\\n29767:     if( i==0 || tnum==0 ){\\n29768:       sqlite3_fprintf(stderr,\"no such index: \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n29769:       rc = 1;\\n29770:       sqlite3_free(zCollist);\\n29771:       goto meta_command_exit;\\n29772:     }\\n29773:     if( lenPK==0 ) lenPK = 100000;\\n29774:     zSql = sqlite3_mprintf(\\n29775:           \"CREATE TABLE \\\\\"%w\\\\\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\",\\n29776:           azArg[2], zCollist, lenPK, zCollist);\\n29777:     sqlite3_free(zCollist);\\n29778:     rc = sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, \"main\", 1, tnum);\\n29779:     if( rc==SQLITE_OK ){\\n29780:       rc = sqlite3_exec(p->db, zSql, 0, 0, 0);\\n29781:       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, \"main\", 0, 0);\\n29782:       if( rc ){\\n29783:         sqlite3_fprintf(stderr,\\n29784:               \"Error in [%s]: %s\\\\n\", zSql, sqlite3_errmsg(p->db));\\n29785:       }else{\\n29786:         sqlite3_fprintf(stdout, \"%s;\\\\n\", zSql);\\n29787:         sqlite3_fprintf(stdout,\\n29788:               \"WARNING: writing to an imposter table will corrupt\"\\n29789:               \" the \\\\\"%s\\\\\" %s!\\\\n\", azArg[1], isWO ? \"table\" : \"index\");\\n29790:       }\\n29791:     }else{\\n29792:       sqlite3_fprintf(stderr,\"SQLITE_TESTCTRL_IMPOSTER returns %d\\\\n\", rc);\\n29793:       rc = 1;\\n29794:     }\\n29795:     sqlite3_free(zSql);\\n29796:   }else\\n29797: #endif /* !defined(SQLITE_OMIT_TEST_CONTROL) */\\n29798: \\n29799:   if( c==\\'i\\' && cli_strncmp(azArg[0], \"intck\", n)==0 ){\\n29800:     i64 iArg = 0;\\n29801:     if( nArg==2 ){\\n29802:       iArg = integerValue(azArg[1]);\\n29803:       if( iArg==0 ) iArg = -1;\\n29804:     }\\n29805:     if( (nArg!=1 && nArg!=2) || iArg<0 ){\\n29806:       sqlite3_fprintf(stderr,\"%s\",\"Usage: .intck STEPS_PER_UNLOCK\\\\n\");\\n29807:       rc = 1;\\n29808:       goto meta_command_exit;\\n29809:     }\\n29810:     open_db(p, 0);\\n29811:     rc = intckDatabaseCmd(p, iArg);\\n29812:   }else\\n29813: \\n29814: #ifdef SQLITE_ENABLE_IOTRACE\\n29815:   if( c==\\'i\\' && cli_strncmp(azArg[0], \"iotrace\", n)==0 ){\\n29816:     SQLITE_API extern void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...);\\n29817:     if( iotrace && iotrace!=stdout ) fclose(iotrace);\\n29818:     iotrace = 0;\\n29819:     if( nArg<2 ){\\n29820:       sqlite3IoTrace = 0;\\n29821:     }else if( cli_strcmp(azArg[1], \"-\")==0 ){\\n29822:       sqlite3IoTrace = iotracePrintf;\\n29823:       iotrace = stdout;\\n29824:     }else{\\n29825:       iotrace = sqlite3_fopen(azArg[1], \"w\");\\n29826:       if( iotrace==0 ){\\n29827:         sqlite3_fprintf(stderr,\"Error: cannot open \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n29828:         sqlite3IoTrace = 0;\\n29829:         rc = 1;\\n29830:       }else{\\n29831:         sqlite3IoTrace = iotracePrintf;\\n29832:       }\\n29833:     }\\n29834:   }else\\n29835: #endif\\n29836: \\n29837:   if( c==\\'l\\' && n>=5 && cli_strncmp(azArg[0], \"limits\", n)==0 ){\\n29838:     static const struct {\\n29839:        const char *zLimitName;   /* Name of a limit */\\n29840:        int limitCode;            /* Integer code for that limit */\\n29841:     } aLimit[] = {\\n29842:       { \"length\",                SQLITE_LIMIT_LENGTH                    },\\n29843:       { \"sql_length\",            SQLITE_LIMIT_SQL_LENGTH                },\\n29844:       { \"column\",                SQLITE_LIMIT_COLUMN                    },\\n29845:       { \"expr_depth\",            SQLITE_LIMIT_EXPR_DEPTH                },\\n29846:       { \"compound_select\",       SQLITE_LIMIT_COMPOUND_SELECT           },\\n29847:       { \"vdbe_op\",               SQLITE_LIMIT_VDBE_OP                   },\\n29848:       { \"function_arg\",          SQLITE_LIMIT_FUNCTION_ARG              },\\n29849:       { \"attached\",              SQLITE_LIMIT_ATTACHED                  },\\n29850:       { \"like_pattern_length\",   SQLITE_LIMIT_LIKE_PATTERN_LENGTH       },\\n29851:       { \"variable_number\",       SQLITE_LIMIT_VARIABLE_NUMBER           },\\n29852:       { \"trigger_depth\",         SQLITE_LIMIT_TRIGGER_DEPTH             },\\n29853:       { \"worker_threads\",        SQLITE_LIMIT_WORKER_THREADS            },\\n29854:     };\\n29855:     int i, n2;\\n29856:     open_db(p, 0);\\n29857:     if( nArg==1 ){\\n29858:       for(i=0; i<ArraySize(aLimit); i++){\\n29859:         sqlite3_fprintf(stdout, \"%20s %d\\\\n\", aLimit[i].zLimitName,\\n29860:               sqlite3_limit(p->db, aLimit[i].limitCode, -1));\\n29861:       }\\n29862:     }else if( nArg>3 ){\\n29863:       eputz(\"Usage: .limit NAME ?NEW-VALUE?\\\\n\");\\n29864:       rc = 1;\\n29865:       goto meta_command_exit;\\n29866:     }else{\\n29867:       int iLimit = -1;\\n29868:       n2 = strlen30(azArg[1]);\\n29869:       for(i=0; i<ArraySize(aLimit); i++){\\n29870:         if( sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2)==0 ){\\n29871:           if( iLimit<0 ){\\n29872:             iLimit = i;\\n29873:           }else{\\n29874:             sqlite3_fprintf(stderr,\"ambiguous limit: \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n29875:             rc = 1;\\n29876:             goto meta_command_exit;\\n29877:           }\\n29878:         }\\n29879:       }\\n29880:       if( iLimit<0 ){\\n29881:         sqlite3_fprintf(stderr,\"unknown limit: \\\\\"%s\\\\\"\\\\n\"\\n29882:               \"enter \\\\\".limits\\\\\" with no arguments for a list.\\\\n\",\\n29883:               azArg[1]);\\n29884:         rc = 1;\\n29885:         goto meta_command_exit;\\n29886:       }\\n29887:       if( nArg==3 ){\\n29888:         sqlite3_limit(p->db, aLimit[iLimit].limitCode,\\n29889:                       (int)integerValue(azArg[2]));\\n29890:       }\\n29891:       sqlite3_fprintf(stdout, \"%20s %d\\\\n\", aLimit[iLimit].zLimitName,\\n29892:             sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));\\n29893:     }\\n29894:   }else\\n29895: \\n29896:   if( c==\\'l\\' && n>2 && cli_strncmp(azArg[0], \"lint\", n)==0 ){\\n29897:     open_db(p, 0);\\n29898:     lintDotCommand(p, azArg, nArg);\\n29899:   }else\\n29900: \\n29901: #if !defined(SQLITE_OMIT_LOAD_EXTENSION) && !defined(SQLITE_SHELL_FIDDLE)\\n29902:   if( c==\\'l\\' && cli_strncmp(azArg[0], \"load\", n)==0 ){\\n29903:     const char *zFile, *zProc;\\n29904:     char *zErrMsg = 0;\\n29905:     failIfSafeMode(p, \"cannot run .load in safe mode\");\\n29906:     if( nArg<2 || azArg[1][0]==0 ){\\n29907:       /* Must have a non-empty FILE. (Will not load self.) */\\n29908:       eputz(\"Usage: .load FILE ?ENTRYPOINT?\\\\n\");\\n29909:       rc = 1;\\n29910:       goto meta_command_exit;\\n29911:     }\\n29912:     zFile = azArg[1];\\n29913:     zProc = nArg>=3 ? azArg[2] : 0;\\n29914:     open_db(p, 0);\\n29915:     rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);\\n29916:     if( rc!=SQLITE_OK ){\\n29917:       shellEmitError(zErrMsg);\\n29918:       sqlite3_free(zErrMsg);\\n29919:       rc = 1;\\n29920:     }\\n29921:   }else\\n29922: #endif\\n29923: \\n29924:   if( c==\\'l\\' && cli_strncmp(azArg[0], \"log\", n)==0 ){\\n29925:     if( nArg!=2 ){\\n29926:       eputz(\"Usage: .log FILENAME\\\\n\");\\n29927:       rc = 1;\\n29928:     }else{\\n29929:       const char *zFile = azArg[1];\\n29930:       if( p->bSafeMode\\n29931:        && cli_strcmp(zFile,\"on\")!=0\\n29932:        && cli_strcmp(zFile,\"off\")!=0\\n29933:       ){\\n29934:         sputz(stdout, \"cannot set .log to anything other\"\\n29935:               \" than \\\\\"on\\\\\" or \\\\\"off\\\\\"\\\\n\");\\n29936:         zFile = \"off\";\\n29937:       }\\n29938:       output_file_close(p->pLog);\\n29939:       if( cli_strcmp(zFile,\"on\")==0 ) zFile = \"stdout\";\\n29940:       p->pLog = output_file_open(zFile);\\n29941:     }\\n29942:   }else\\n29943: \\n29944:   if( c==\\'m\\' && cli_strncmp(azArg[0], \"mode\", n)==0 ){\\n29945:     const char *zMode = 0;\\n29946:     const char *zTabname = 0;\\n29947:     int i, n2;\\n29948:     ColModeOpts cmOpts = ColModeOpts_default;\\n29949:     for(i=1; i<nArg; i++){\\n29950:       const char *z = azArg[i];\\n29951:       if( optionMatch(z,\"wrap\") && i+1<nArg ){\\n29952:         cmOpts.iWrap = integerValue(azArg[++i]);\\n29953:       }else if( optionMatch(z,\"ww\") ){\\n29954:         cmOpts.bWordWrap = 1;\\n29955:       }else if( optionMatch(z,\"wordwrap\") && i+1<nArg ){\\n29956:         cmOpts.bWordWrap = (u8)booleanValue(azArg[++i]);\\n29957:       }else if( optionMatch(z,\"quote\") ){\\n29958:         cmOpts.bQuote = 1;\\n29959:       }else if( optionMatch(z,\"noquote\") ){\\n29960:         cmOpts.bQuote = 0;\\n29961:       }else if( zMode==0 ){\\n29962:         zMode = z;\\n29963:         /* Apply defaults for qbox pseudo-mode.  If that\\n29964:          * overwrites already-set values, user was informed of this.\\n29965:          */\\n29966:         if( cli_strcmp(z, \"qbox\")==0 ){\\n29967:           ColModeOpts cmo = ColModeOpts_default_qbox;\\n29968:           zMode = \"box\";\\n29969:           cmOpts = cmo;\\n29970:         }\\n29971:       }else if( zTabname==0 ){\\n29972:         zTabname = z;\\n29973:       }else if( z[0]==\\'-\\' ){\\n29974:         sqlite3_fprintf(stderr,\"unknown option: %s\\\\n\", z);\\n29975:         eputz(\"options:\\\\n\"\\n29976:               \"  --noquote\\\\n\"\\n29977:               \"  --quote\\\\n\"\\n29978:               \"  --wordwrap on/off\\\\n\"\\n29979:               \"  --wrap N\\\\n\"\\n29980:               \"  --ww\\\\n\");\\n29981:         rc = 1;\\n29982:         goto meta_command_exit;\\n29983:       }else{\\n29984:         sqlite3_fprintf(stderr,\"extra argument: \\\\\"%s\\\\\"\\\\n\", z);\\n29985:         rc = 1;\\n29986:         goto meta_command_exit;\\n29987:       }\\n29988:     }\\n29989:     if( zMode==0 ){\\n29990:       if( p->mode==MODE_Column\\n29991:        || (p->mode>=MODE_Markdown && p->mode<=MODE_Box)\\n29992:       ){\\n29993:         sqlite3_fprintf(p->out,\\n29994:               \"current output mode: %s --wrap %d --wordwrap %s --%squote\\\\n\",\\n29995:               modeDescr[p->mode], p->cmOpts.iWrap,\\n29996:               p->cmOpts.bWordWrap ? \"on\" : \"off\",\\n29997:               p->cmOpts.bQuote ? \"\" : \"no\");\\n29998:       }else{\\n29999:         sqlite3_fprintf(p->out,\\n30000:               \"current output mode: %s\\\\n\", modeDescr[p->mode]);\\n30001:       }\\n30002:       zMode = modeDescr[p->mode];\\n30003:     }\\n30004:     n2 = strlen30(zMode);\\n30005:     if( cli_strncmp(zMode,\"lines\",n2)==0 ){\\n30006:       p->mode = MODE_Line;\\n30007:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\\n30008:     }else if( cli_strncmp(zMode,\"columns\",n2)==0 ){\\n30009:       p->mode = MODE_Column;\\n30010:       if( (p->shellFlgs & SHFLG_HeaderSet)==0 ){\\n30011:         p->showHeader = 1;\\n30012:       }\\n30013:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\\n30014:       p->cmOpts = cmOpts;\\n30015:     }else if( cli_strncmp(zMode,\"list\",n2)==0 ){\\n30016:       p->mode = MODE_List;\\n30017:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Column);\\n30018:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\\n30019:     }else if( cli_strncmp(zMode,\"html\",n2)==0 ){\\n30020:       p->mode = MODE_Html;\\n30021:     }else if( cli_strncmp(zMode,\"tcl\",n2)==0 ){\\n30022:       p->mode = MODE_Tcl;\\n30023:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Space);\\n30024:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\\n30025:     }else if( cli_strncmp(zMode,\"csv\",n2)==0 ){\\n30026:       p->mode = MODE_Csv;\\n30027:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);\\n30028:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);\\n30029:     }else if( cli_strncmp(zMode,\"tabs\",n2)==0 ){\\n30030:       p->mode = MODE_List;\\n30031:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Tab);\\n30032:     }else if( cli_strncmp(zMode,\"insert\",n2)==0 ){\\n30033:       p->mode = MODE_Insert;\\n30034:       set_table_name(p, zTabname ? zTabname : \"table\");\\n30035:     }else if( cli_strncmp(zMode,\"quote\",n2)==0 ){\\n30036:       p->mode = MODE_Quote;\\n30037:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);\\n30038:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\\n30039:     }else if( cli_strncmp(zMode,\"ascii\",n2)==0 ){\\n30040:       p->mode = MODE_Ascii;\\n30041:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Unit);\\n30042:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Record);\\n30043:     }else if( cli_strncmp(zMode,\"markdown\",n2)==0 ){\\n30044:       p->mode = MODE_Markdown;\\n30045:       p->cmOpts = cmOpts;\\n30046:     }else if( cli_strncmp(zMode,\"table\",n2)==0 ){\\n30047:       p->mode = MODE_Table;\\n30048:       p->cmOpts = cmOpts;\\n30049:     }else if( cli_strncmp(zMode,\"box\",n2)==0 ){\\n30050:       p->mode = MODE_Box;\\n30051:       p->cmOpts = cmOpts;\\n30052:     }else if( cli_strncmp(zMode,\"count\",n2)==0 ){\\n30053:       p->mode = MODE_Count;\\n30054:     }else if( cli_strncmp(zMode,\"off\",n2)==0 ){\\n30055:       p->mode = MODE_Off;\\n30056:     }else if( cli_strncmp(zMode,\"json\",n2)==0 ){\\n30057:       p->mode = MODE_Json;\\n30058:     }else{\\n30059:       eputz(\"Error: mode should be one of: \"\\n30060:             \"ascii box column csv html insert json line list markdown \"\\n30061:             \"qbox quote table tabs tcl\\\\n\");\\n30062:       rc = 1;\\n30063:     }\\n30064:     p->cMode = p->mode;\\n30065:   }else\\n30066: \\n30067: #ifndef SQLITE_SHELL_FIDDLE\\n30068:   if( c==\\'n\\' && cli_strcmp(azArg[0], \"nonce\")==0 ){\\n30069:     if( nArg!=2 ){\\n30070:       eputz(\"Usage: .nonce NONCE\\\\n\");\\n30071:       rc = 1;\\n30072:     }else if( p->zNonce==0 || cli_strcmp(azArg[1],p->zNonce)!=0 ){\\n30073:       sqlite3_fprintf(stderr,\"line %d: incorrect nonce: \\\\\"%s\\\\\"\\\\n\",\\n30074:             p->lineno, azArg[1]);\\n30075:       exit(1);\\n30076:     }else{\\n30077:       p->bSafeMode = 0;\\n30078:       return 0;  /* Return immediately to bypass the safe mode reset\\n30079:                  ** at the end of this procedure */\\n30080:     }\\n30081:   }else\\n30082: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n30083: \\n30084:   if( c==\\'n\\' && cli_strncmp(azArg[0], \"nullvalue\", n)==0 ){\\n30085:     if( nArg==2 ){\\n30086:       sqlite3_snprintf(sizeof(p->nullValue), p->nullValue,\\n30087:                        \"%.*s\", (int)ArraySize(p->nullValue)-1, azArg[1]);\\n30088:     }else{\\n30089:       eputz(\"Usage: .nullvalue STRING\\\\n\");\\n30090:       rc = 1;\\n30091:     }\\n30092:   }else\\n30093: \\n30094:   if( c==\\'o\\' && cli_strncmp(azArg[0], \"open\", n)==0 && n>=2 ){\\n30095:     const char *zFN = 0;     /* Pointer to constant filename */\\n30096:     char *zNewFilename = 0;  /* Name of the database file to open */\\n30097:     int iName = 1;           /* Index in azArg[] of the filename */\\n30098:     int newFlag = 0;         /* True to delete file before opening */\\n30099:     int openMode = SHELL_OPEN_UNSPEC;\\n30100: \\n30101:     /* Check for command-line arguments */\\n30102:     for(iName=1; iName<nArg; iName++){\\n30103:       const char *z = azArg[iName];\\n30104: #ifndef SQLITE_SHELL_FIDDLE\\n30105:       if( optionMatch(z,\"new\") ){\\n30106:         newFlag = 1;\\n30107: #ifdef SQLITE_HAVE_ZLIB\\n30108:       }else if( optionMatch(z, \"zip\") ){\\n30109:         openMode = SHELL_OPEN_ZIPFILE;\\n30110: #endif\\n30111:       }else if( optionMatch(z, \"append\") ){\\n30112:         openMode = SHELL_OPEN_APPENDVFS;\\n30113:       }else if( optionMatch(z, \"readonly\") ){\\n30114:         openMode = SHELL_OPEN_READONLY;\\n30115:       }else if( optionMatch(z, \"nofollow\") ){\\n30116:         p->openFlags |= SQLITE_OPEN_NOFOLLOW;\\n30117: #ifndef SQLITE_OMIT_DESERIALIZE\\n30118:       }else if( optionMatch(z, \"deserialize\") ){\\n30119:         openMode = SHELL_OPEN_DESERIALIZE;\\n30120:       }else if( optionMatch(z, \"hexdb\") ){\\n30121:         openMode = SHELL_OPEN_HEXDB;\\n30122:       }else if( optionMatch(z, \"maxsize\") && iName+1<nArg ){\\n30123:         p->szMax = integerValue(azArg[++iName]);\\n30124: #endif /* SQLITE_OMIT_DESERIALIZE */\\n30125:       }else\\n30126: #endif /* !SQLITE_SHELL_FIDDLE */\\n30127:       if( z[0]==\\'-\\' ){\\n30128:         sqlite3_fprintf(stderr,\"unknown option: %s\\\\n\", z);\\n30129:         rc = 1;\\n30130:         goto meta_command_exit;\\n30131:       }else if( zFN ){\\n30132:         sqlite3_fprintf(stderr,\"extra argument: \\\\\"%s\\\\\"\\\\n\", z);\\n30133:         rc = 1;\\n30134:         goto meta_command_exit;\\n30135:       }else{\\n30136:         zFN = z;\\n30137:       }\\n30138:     }\\n30139: \\n30140:     /* Close the existing database */\\n30141:     session_close_all(p, -1);\\n30142:     close_db(p->db);\\n30143:     p->db = 0;\\n30144:     p->pAuxDb->zDbFilename = 0;\\n30145:     sqlite3_free(p->pAuxDb->zFreeOnClose);\\n30146:     p->pAuxDb->zFreeOnClose = 0;\\n30147:     p->openMode = openMode;\\n30148:     p->openFlags = 0;\\n30149:     p->szMax = 0;\\n30150: \\n30151:     /* If a filename is specified, try to open it first */\\n30152:     if( zFN || p->openMode==SHELL_OPEN_HEXDB ){\\n30153:       if( newFlag && zFN && !p->bSafeMode ) shellDeleteFile(zFN);\\n30154: #ifndef SQLITE_SHELL_FIDDLE\\n30155:       if( p->bSafeMode\\n30156:        && p->openMode!=SHELL_OPEN_HEXDB\\n30157:        && zFN\\n30158:        && cli_strcmp(zFN,\":memory:\")!=0\\n30159:       ){\\n30160:         failIfSafeMode(p, \"cannot open disk-based database files in safe mode\");\\n30161:       }\\n30162: #else\\n30163:       /* WASM mode has its own sandboxed pseudo-filesystem. */\\n30164: #endif\\n30165:       if( zFN ){\\n30166:         zNewFilename = sqlite3_mprintf(\"%s\", zFN);\\n30167:         shell_check_oom(zNewFilename);\\n30168:       }else{\\n30169:         zNewFilename = 0;\\n30170:       }\\n30171:       p->pAuxDb->zDbFilename = zNewFilename;\\n30172:       open_db(p, OPEN_DB_KEEPALIVE);\\n30173:       if( p->db==0 ){\\n30174:         sqlite3_fprintf(stderr,\"Error: cannot open \\'%s\\'\\\\n\", zNewFilename);\\n30175:         sqlite3_free(zNewFilename);\\n30176:       }else{\\n30177:         p->pAuxDb->zFreeOnClose = zNewFilename;\\n30178:       }\\n30179:     }\\n30180:     if( p->db==0 ){\\n30181:       /* As a fall-back open a TEMP database */\\n30182:       p->pAuxDb->zDbFilename = 0;\\n30183:       open_db(p, 0);\\n30184:     }\\n30185:   }else\\n30186: \\n30187: #ifndef SQLITE_SHELL_FIDDLE\\n30188:   if( (c==\\'o\\'\\n30189:         && (cli_strncmp(azArg[0], \"output\", n)==0\\n30190:             || cli_strncmp(azArg[0], \"once\", n)==0))\\n30191:    || (c==\\'e\\' && n==5 && cli_strcmp(azArg[0],\"excel\")==0)\\n30192:    || (c==\\'w\\' && n==3 && cli_strcmp(azArg[0],\"www\")==0)\\n30193:   ){\\n30194:     char *zFile = 0;\\n30195:     int i;\\n30196:     int eMode = 0;\\n30197:     int bOnce = 0;            /* 0: .output, 1: .once, 2: .excel/.www */\\n30198:     int bPlain = 0;           /* --plain option */\\n30199:     static const char *zBomUtf8 = \"\\\\357\\\\273\\\\277\";\\n30200:     const char *zBom = 0;\\n30201: \\n30202:     failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\\n30203:     if( c==\\'e\\' ){\\n30204:       eMode = \\'x\\';\\n30205:       bOnce = 2;\\n30206:     }else if( c==\\'w\\' ){\\n30207:       eMode = \\'w\\';\\n30208:       bOnce = 2;\\n30209:     }else if( cli_strncmp(azArg[0],\"once\",n)==0 ){\\n30210:       bOnce = 1;\\n30211:     }\\n30212:     for(i=1; i<nArg; i++){\\n30213:       char *z = azArg[i];\\n30214:       if( z[0]==\\'-\\' ){\\n30215:         if( z[1]==\\'-\\' ) z++;\\n30216:         if( cli_strcmp(z,\"-bom\")==0 ){\\n30217:           zBom = zBomUtf8;\\n30218:         }else if( cli_strcmp(z,\"-plain\")==0 ){\\n30219:           bPlain = 1;\\n30220:         }else if( c==\\'o\\' && cli_strcmp(z,\"-x\")==0 ){\\n30221:           eMode = \\'x\\';  /* spreadsheet */\\n30222:         }else if( c==\\'o\\' && cli_strcmp(z,\"-e\")==0 ){\\n30223:           eMode = \\'e\\';  /* text editor */\\n30224:         }else if( c==\\'o\\' && cli_strcmp(z,\"-w\")==0 ){\\n30225:           eMode = \\'w\\';  /* Web browser */\\n30226:         }else{\\n30227:           sqlite3_fprintf(p->out, \\n30228:                           \"ERROR: unknown option: \\\\\"%s\\\\\". Usage:\\\\n\", azArg[i]);\\n30229:           showHelp(p->out, azArg[0]);\\n30230:           rc = 1;\\n30231:           goto meta_command_exit;\\n30232:         }\\n30233:       }else if( zFile==0 && eMode==0 ){\\n30234:         zFile = sqlite3_mprintf(\"%s\", z);\\n30235:         if( zFile && zFile[0]==\\'|\\' ){\\n30236:           while( i+1<nArg ) zFile = sqlite3_mprintf(\"%z %s\", zFile, azArg[++i]);\\n30237:           break;\\n30238:         }\\n30239:       }else{\\n30240:         sqlite3_fprintf(p->out,\\n30241:             \"ERROR: extra parameter: \\\\\"%s\\\\\".  Usage:\\\\n\", azArg[i]);\\n30242:         showHelp(p->out, azArg[0]);\\n30243:         rc = 1;\\n30244:         sqlite3_free(zFile);\\n30245:         goto meta_command_exit;\\n30246:       }\\n30247:     }\\n30248:     if( zFile==0 ){\\n30249:       zFile = sqlite3_mprintf(\"stdout\");\\n30250:     }\\n30251:     shell_check_oom(zFile);\\n30252:     if( bOnce ){\\n30253:       p->outCount = 2;\\n30254:     }else{\\n30255:       p->outCount = 0;\\n30256:     }\\n30257:     output_reset(p);\\n30258: #ifndef SQLITE_NOHAVE_SYSTEM\\n30259:     if( eMode==\\'e\\' || eMode==\\'x\\' || eMode==\\'w\\' ){\\n30260:       p->doXdgOpen = 1;\\n30261:       outputModePush(p);\\n30262:       if( eMode==\\'x\\' ){\\n30263:         /* spreadsheet mode.  Output as CSV. */\\n30264:         newTempFile(p, \"csv\");\\n30265:         ShellClearFlag(p, SHFLG_Echo);\\n30266:         p->mode = MODE_Csv;\\n30267:         sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);\\n30268:         sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);\\n30269: #ifdef _WIN32\\n30270:         zBom = zBomUtf8;  /* Always include the BOM on Windows, as Excel does\\n30271:                           ** not work without it. */\\n30272: #endif\\n30273:       }else if( eMode==\\'w\\' ){\\n30274:         /* web-browser mode. */\\n30275:         newTempFile(p, \"html\");\\n30276:         if( !bPlain ) p->mode = MODE_Www;\\n30277:       }else{\\n30278:         /* text editor mode */\\n30279:         newTempFile(p, \"txt\");\\n30280:       }\\n30281:       sqlite3_free(zFile);\\n30282:       zFile = sqlite3_mprintf(\"%s\", p->zTempFile);\\n30283:     }\\n30284: #endif /* SQLITE_NOHAVE_SYSTEM */\\n30285:     shell_check_oom(zFile);\\n30286:     if( zFile[0]==\\'|\\' ){\\n30287: #ifdef SQLITE_OMIT_POPEN\\n30288:       eputz(\"Error: pipes are not supported in this OS\\\\n\");\\n30289:       rc = 1;\\n30290:       output_redir(p, stdout);\\n30291: #else\\n30292:       FILE *pfPipe = sqlite3_popen(zFile + 1, \"w\");\\n30293:       if( pfPipe==0 ){\\n30294:         assert( stderr!=NULL );\\n30295:         sqlite3_fprintf(stderr,\"Error: cannot open pipe \\\\\"%s\\\\\"\\\\n\", zFile + 1);\\n30296:         rc = 1;\\n30297:       }else{\\n30298:         output_redir(p, pfPipe);\\n30299:         if( zBom ) sqlite3_fputs(zBom, pfPipe);\\n30300:         sqlite3_snprintf(sizeof(p->outfile), p->outfile, \"%s\", zFile);\\n30301:       }\\n30302: #endif\\n30303:     }else{\\n30304:       FILE *pfFile = output_file_open(zFile);\\n30305:       if( pfFile==0 ){\\n30306:         if( cli_strcmp(zFile,\"off\")!=0 ){\\n30307:          assert( stderr!=NULL );\\n30308:          sqlite3_fprintf(stderr,\"Error: cannot write to \\\\\"%s\\\\\"\\\\n\", zFile);\\n30309:         }\\n30310:         rc = 1;\\n30311:       } else {\\n30312:         output_redir(p, pfFile);\\n30313:         if( zBom ) sqlite3_fputs(zBom, pfFile);\\n30314:         if( bPlain && eMode==\\'w\\' ){\\n30315:           sqlite3_fputs(\\n30316:             \"<!DOCTYPE html>\\\\n<BODY>\\\\n<PLAINTEXT>\\\\n\",\\n30317:             pfFile\\n30318:           );\\n30319:         }\\n30320:         sqlite3_snprintf(sizeof(p->outfile), p->outfile, \"%s\", zFile);\\n30321:       }\\n30322:     }\\n30323:     sqlite3_free(zFile);\\n30324:   }else\\n30325: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n30326: \\n30327:   if( c==\\'p\\' && n>=3 && cli_strncmp(azArg[0], \"parameter\", n)==0 ){\\n30328:     open_db(p,0);\\n30329:     if( nArg<=1 ) goto parameter_syntax_error;\\n30330: \\n30331:     /* .parameter clear\\n30332:     ** Clear all bind parameters by dropping the TEMP table that holds them.\\n30333:     */\\n30334:     if( nArg==2 && cli_strcmp(azArg[1],\"clear\")==0 ){\\n30335:       sqlite3_exec(p->db, \"DROP TABLE IF EXISTS temp.sqlite_parameters;\",\\n30336:                    0, 0, 0);\\n30337:     }else\\n30338: \\n30339:     /* .parameter list\\n30340:     ** List all bind parameters.\\n30341:     */\\n30342:     if( nArg==2 && cli_strcmp(azArg[1],\"list\")==0 ){\\n30343:       sqlite3_stmt *pStmt = 0;\\n30344:       int rx;\\n30345:       int len = 0;\\n30346:       rx = sqlite3_prepare_v2(p->db,\\n30347:              \"SELECT max(length(key)) \"\\n30348:              \"FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\\n30349:       if( rx==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){\\n30350:         len = sqlite3_column_int(pStmt, 0);\\n30351:         if( len>40 ) len = 40;\\n30352:       }\\n30353:       sqlite3_finalize(pStmt);\\n30354:       pStmt = 0;\\n30355:       if( len ){\\n30356:         rx = sqlite3_prepare_v2(p->db,\\n30357:              \"SELECT key, quote(value) \"\\n30358:              \"FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\\n30359:         while( rx==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){\\n30360:           sqlite3_fprintf(p->out,\\n30361:                 \"%-*s %s\\\\n\", len, sqlite3_column_text(pStmt,0),\\n30362:                 sqlite3_column_text(pStmt,1));\\n30363:         }\\n30364:         sqlite3_finalize(pStmt);\\n30365:       }\\n30366:     }else\\n30367: \\n30368:     /* .parameter init\\n30369:     ** Make sure the TEMP table used to hold bind parameters exists.\\n30370:     ** Create it if necessary.\\n30371:     */\\n30372:     if( nArg==2 && cli_strcmp(azArg[1],\"init\")==0 ){\\n30373:       bind_table_init(p);\\n30374:     }else\\n30375: \\n30376:     /* .parameter set NAME VALUE\\n30377:     ** Set or reset a bind parameter.  NAME should be the full parameter\\n30378:     ** name exactly as it appears in the query.  (ex: $abc, @def).  The\\n30379:     ** VALUE can be in either SQL literal notation, or if not it will be\\n30380:     ** understood to be a text string.\\n30381:     */\\n30382:     if( nArg==4 && cli_strcmp(azArg[1],\"set\")==0 ){\\n30383:       int rx;\\n30384:       char *zSql;\\n30385:       sqlite3_stmt *pStmt;\\n30386:       const char *zKey = azArg[2];\\n30387:       const char *zValue = azArg[3];\\n30388:       bind_table_init(p);\\n30389:       zSql = sqlite3_mprintf(\\n30390:                   \"REPLACE INTO temp.sqlite_parameters(key,value)\"\\n30391:                   \"VALUES(%Q,%s);\", zKey, zValue);\\n30392:       shell_check_oom(zSql);\\n30393:       pStmt = 0;\\n30394:       rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n30395:       sqlite3_free(zSql);\\n30396:       if( rx!=SQLITE_OK ){\\n30397:         sqlite3_finalize(pStmt);\\n30398:         pStmt = 0;\\n30399:         zSql = sqlite3_mprintf(\\n30400:                    \"REPLACE INTO temp.sqlite_parameters(key,value)\"\\n30401:                    \"VALUES(%Q,%Q);\", zKey, zValue);\\n30402:         shell_check_oom(zSql);\\n30403:         rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n30404:         sqlite3_free(zSql);\\n30405:         if( rx!=SQLITE_OK ){\\n30406:           sqlite3_fprintf(p->out, \"Error: %s\\\\n\", sqlite3_errmsg(p->db));\\n30407:           sqlite3_finalize(pStmt);\\n30408:           pStmt = 0;\\n30409:           rc = 1;\\n30410:         }\\n30411:       }\\n30412:       bind_prepared_stmt(p, pStmt);\\n30413:       sqlite3_step(pStmt);\\n30414:       sqlite3_finalize(pStmt);\\n30415:     }else\\n30416: \\n30417:     /* .parameter unset NAME\\n30418:     ** Remove the NAME binding from the parameter binding table, if it\\n30419:     ** exists.\\n30420:     */\\n30421:     if( nArg==3 && cli_strcmp(azArg[1],\"unset\")==0 ){\\n30422:       char *zSql = sqlite3_mprintf(\\n30423:           \"DELETE FROM temp.sqlite_parameters WHERE key=%Q\", azArg[2]);\\n30424:       shell_check_oom(zSql);\\n30425:       sqlite3_exec(p->db, zSql, 0, 0, 0);\\n30426:       sqlite3_free(zSql);\\n30427:     }else\\n30428:     /* If no command name matches, show a syntax error */\\n30429:     parameter_syntax_error:\\n30430:     showHelp(p->out, \"parameter\");\\n30431:   }else\\n30432: \\n30433:   if( c==\\'p\\' && n>=3 && cli_strncmp(azArg[0], \"print\", n)==0 ){\\n30434:     int i;\\n30435:     for(i=1; i<nArg; i++){\\n30436:       if( i>1 ) sqlite3_fputs(\" \", p->out);\\n30437:       sqlite3_fputs(azArg[i], p->out);\\n30438:     }\\n30439:     sqlite3_fputs(\"\\\\n\", p->out);\\n30440:   }else\\n30441: \\n30442: #ifndef SQLITE_OMIT_PROGRESS_CALLBACK\\n30443:   if( c==\\'p\\' && n>=3 && cli_strncmp(azArg[0], \"progress\", n)==0 ){\\n30444:     int i;\\n30445:     int nn = 0;\\n30446:     p->flgProgress = 0;\\n30447:     p->mxProgress = 0;\\n30448:     p->nProgress = 0;\\n30449:     for(i=1; i<nArg; i++){\\n30450:       const char *z = azArg[i];\\n30451:       if( z[0]==\\'-\\' ){\\n30452:         z++;\\n30453:         if( z[0]==\\'-\\' ) z++;\\n30454:         if( cli_strcmp(z,\"quiet\")==0 || cli_strcmp(z,\"q\")==0 ){\\n30455:           p->flgProgress |= SHELL_PROGRESS_QUIET;\\n30456:           continue;\\n30457:         }\\n30458:         if( cli_strcmp(z,\"reset\")==0 ){\\n30459:           p->flgProgress |= SHELL_PROGRESS_RESET;\\n30460:           continue;\\n30461:         }\\n30462:         if( cli_strcmp(z,\"once\")==0 ){\\n30463:           p->flgProgress |= SHELL_PROGRESS_ONCE;\\n30464:           continue;\\n30465:         }\\n30466:         if( cli_strcmp(z,\"limit\")==0 ){\\n30467:           if( i+1>=nArg ){\\n30468:             eputz(\"Error: missing argument on --limit\\\\n\");\\n30469:             rc = 1;\\n30470:             goto meta_command_exit;\\n30471:           }else{\\n30472:             p->mxProgress = (int)integerValue(azArg[++i]);\\n30473:           }\\n30474:           continue;\\n30475:         }\\n30476:         sqlite3_fprintf(stderr,\"Error: unknown option: \\\\\"%s\\\\\"\\\\n\", azArg[i]);\\n30477:         rc = 1;\\n30478:         goto meta_command_exit;\\n30479:       }else{\\n30480:         nn = (int)integerValue(z);\\n30481:       }\\n30482:     }\\n30483:     open_db(p, 0);\\n30484:     sqlite3_progress_handler(p->db, nn, progress_handler, p);\\n30485:   }else\\n30486: #endif /* SQLITE_OMIT_PROGRESS_CALLBACK */\\n30487: \\n30488:   if( c==\\'p\\' && cli_strncmp(azArg[0], \"prompt\", n)==0 ){\\n30489:     if( nArg >= 2) {\\n30490:       shell_strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\\n30491:     }\\n30492:     if( nArg >= 3) {\\n30493:       shell_strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\\n30494:     }\\n30495:   }else\\n30496: \\n30497: #ifndef SQLITE_SHELL_FIDDLE\\n30498:   if( c==\\'q\\' && cli_strncmp(azArg[0], \"quit\", n)==0 ){\\n30499:     rc = 2;\\n30500:   }else\\n30501: #endif\\n30502: \\n30503: #ifndef SQLITE_SHELL_FIDDLE\\n30504:   if( c==\\'r\\' && n>=3 && cli_strncmp(azArg[0], \"read\", n)==0 ){\\n30505:     FILE *inSaved = p->in;\\n30506:     int savedLineno = p->lineno;\\n30507:     failIfSafeMode(p, \"cannot run .read in safe mode\");\\n30508:     if( nArg!=2 ){\\n30509:       eputz(\"Usage: .read FILE\\\\n\");\\n30510:       rc = 1;\\n30511:       goto meta_command_exit;\\n30512:     }\\n30513:     if( azArg[1][0]==\\'|\\' ){\\n30514: #ifdef SQLITE_OMIT_POPEN\\n30515:       eputz(\"Error: pipes are not supported in this OS\\\\n\");\\n30516:       rc = 1;\\n30517: #else\\n30518:       p->in = sqlite3_popen(azArg[1]+1, \"r\");\\n30519:       if( p->in==0 ){\\n30520:         sqlite3_fprintf(stderr,\"Error: cannot open \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n30521:         rc = 1;\\n30522:       }else{\\n30523:         rc = process_input(p);\\n30524:         pclose(p->in);\\n30525:       }\\n30526: #endif\\n30527:     }else if( (p->in = openChrSource(azArg[1]))==0 ){\\n30528:       sqlite3_fprintf(stderr,\"Error: cannot open \\\\\"%s\\\\\"\\\\n\", azArg[1]);\\n30529:       rc = 1;\\n30530:     }else{\\n30531:       rc = process_input(p);\\n30532:       fclose(p->in);\\n30533:     }\\n30534:     p->in = inSaved;\\n30535:     p->lineno = savedLineno;\\n30536:   }else\\n30537: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n30538: \\n30539: #ifndef SQLITE_SHELL_FIDDLE\\n30540:   if( c==\\'r\\' && n>=3 && cli_strncmp(azArg[0], \"restore\", n)==0 ){\\n30541:     const char *zSrcFile;\\n30542:     const char *zDb;\\n30543:     sqlite3 *pSrc;\\n30544:     sqlite3_backup *pBackup;\\n30545:     int nTimeout = 0;\\n30546: \\n30547:     failIfSafeMode(p, \"cannot run .restore in safe mode\");\\n30548:     if( nArg==2 ){\\n30549:       zSrcFile = azArg[1];\\n30550:       zDb = \"main\";\\n30551:     }else if( nArg==3 ){\\n30552:       zSrcFile = azArg[2];\\n30553:       zDb = azArg[1];\\n30554:     }else{\\n30555:       eputz(\"Usage: .restore ?DB? FILE\\\\n\");\\n30556:       rc = 1;\\n30557:       goto meta_command_exit;\\n30558:     }\\n30559:     rc = sqlite3_open(zSrcFile, &pSrc);\\n30560:     if( rc!=SQLITE_OK ){\\n30561:       sqlite3_fprintf(stderr,\"Error: cannot open \\\\\"%s\\\\\"\\\\n\", zSrcFile);\\n30562:       close_db(pSrc);\\n30563:       return 1;\\n30564:     }\\n30565:     open_db(p, 0);\\n30566:     pBackup = sqlite3_backup_init(p->db, zDb, pSrc, \"main\");\\n30567:     if( pBackup==0 ){\\n30568:       shellDatabaseError(p->db);\\n30569:       close_db(pSrc);\\n30570:       return 1;\\n30571:     }\\n30572:     while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK\\n30573:           || rc==SQLITE_BUSY  ){\\n30574:       if( rc==SQLITE_BUSY ){\\n30575:         if( nTimeout++ >= 3 ) break;\\n30576:         sqlite3_sleep(100);\\n30577:       }\\n30578:     }\\n30579:     sqlite3_backup_finish(pBackup);\\n30580:     if( rc==SQLITE_DONE ){\\n30581:       rc = 0;\\n30582:     }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){\\n30583:       eputz(\"Error: source database is busy\\\\n\");\\n30584:       rc = 1;\\n30585:     }else{\\n30586:       shellDatabaseError(p->db);\\n30587:       rc = 1;\\n30588:     }\\n30589:     close_db(pSrc);\\n30590:   }else\\n30591: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n30592: \\n30593:   if( c==\\'s\\' &&\\n30594:      (cli_strncmp(azArg[0], \"scanstats\",  n)==0 ||\\n30595:       cli_strncmp(azArg[0], \"scanstatus\", n)==0)\\n30596:   ){\\n30597:     if( nArg==2 ){\\n30598:       if( cli_strcmp(azArg[1], \"vm\")==0 ){\\n30599:         p->scanstatsOn = 3;\\n30600:       }else\\n30601:       if( cli_strcmp(azArg[1], \"est\")==0 ){\\n30602:         p->scanstatsOn = 2;\\n30603:       }else{\\n30604:         p->scanstatsOn = (u8)booleanValue(azArg[1]);\\n30605:       }\\n30606:       open_db(p, 0);\\n30607:       sqlite3_db_config(\\n30608:           p->db, SQLITE_DBCONFIG_STMT_SCANSTATUS, p->scanstatsOn, (int*)0\\n30609:       );\\n30610: #if !defined(SQLITE_ENABLE_STMT_SCANSTATUS)\\n30611:       eputz(\"Warning: .scanstats not available in this build.\\\\n\");\\n30612: #elif !defined(SQLITE_ENABLE_BYTECODE_VTAB)\\n30613:       if( p->scanstatsOn==3 ){\\n30614:         eputz(\"Warning: \\\\\".scanstats vm\\\\\" not available in this build.\\\\n\");\\n30615:       }\\n30616: #endif\\n30617:     }else{\\n30618:       eputz(\"Usage: .scanstats on|off|est\\\\n\");\\n30619:       rc = 1;\\n30620:     }\\n30621:   }else\\n30622: \\n30623:   if( c==\\'s\\' && cli_strncmp(azArg[0], \"schema\", n)==0 ){\\n30624:     ShellText sSelect;\\n30625:     ShellState data;\\n30626:     char *zErrMsg = 0;\\n30627:     const char *zDiv = \"(\";\\n30628:     const char *zName = 0;\\n30629:     int iSchema = 0;\\n30630:     int bDebug = 0;\\n30631:     int bNoSystemTabs = 0;\\n30632:     int ii;\\n30633: \\n30634:     open_db(p, 0);\\n30635:     memcpy(&data, p, sizeof(data));\\n30636:     data.showHeader = 0;\\n30637:     data.cMode = data.mode = MODE_Semi;\\n30638:     initText(&sSelect);\\n30639:     for(ii=1; ii<nArg; ii++){\\n30640:       if( optionMatch(azArg[ii],\"indent\") ){\\n30641:         data.cMode = data.mode = MODE_Pretty;\\n30642:       }else if( optionMatch(azArg[ii],\"debug\") ){\\n30643:         bDebug = 1;\\n30644:       }else if( optionMatch(azArg[ii],\"nosys\") ){\\n30645:         bNoSystemTabs = 1;\\n30646:       }else if( azArg[ii][0]==\\'-\\' ){\\n30647:         sqlite3_fprintf(stderr,\"Unknown option: \\\\\"%s\\\\\"\\\\n\", azArg[ii]);\\n30648:         rc = 1;\\n30649:         goto meta_command_exit;\\n30650:       }else if( zName==0 ){\\n30651:         zName = azArg[ii];\\n30652:       }else{\\n30653:         eputz(\"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\\\\n\");\\n30654:         rc = 1;\\n30655:         goto meta_command_exit;\\n30656:       }\\n30657:     }\\n30658:     if( zName!=0 ){\\n30659:       int isSchema = sqlite3_strlike(zName, \"sqlite_master\", \\'\\\\\\\\\\')==0\\n30660:                   || sqlite3_strlike(zName, \"sqlite_schema\", \\'\\\\\\\\\\')==0\\n30661:                   || sqlite3_strlike(zName,\"sqlite_temp_master\", \\'\\\\\\\\\\')==0\\n30662:                   || sqlite3_strlike(zName,\"sqlite_temp_schema\", \\'\\\\\\\\\\')==0;\\n30663:       if( isSchema ){\\n30664:         char *new_argv[2], *new_colv[2];\\n30665:         new_argv[0] = sqlite3_mprintf(\\n30666:                       \"CREATE TABLE %s (\\\\n\"\\n30667:                       \"  type text,\\\\n\"\\n30668:                       \"  name text,\\\\n\"\\n30669:                       \"  tbl_name text,\\\\n\"\\n30670:                       \"  rootpage integer,\\\\n\"\\n30671:                       \"  sql text\\\\n\"\\n30672:                       \")\", zName);\\n30673:         shell_check_oom(new_argv[0]);\\n30674:         new_argv[1] = 0;\\n30675:         new_colv[0] = \"sql\";\\n30676:         new_colv[1] = 0;\\n30677:         callback(&data, 1, new_argv, new_colv);\\n30678:         sqlite3_free(new_argv[0]);\\n30679:       }\\n30680:     }\\n30681:     if( zDiv ){\\n30682:       sqlite3_stmt *pStmt = 0;\\n30683:       rc = sqlite3_prepare_v2(p->db, \"SELECT name FROM pragma_database_list\",\\n30684:                               -1, &pStmt, 0);\\n30685:       if( rc ){\\n30686:         shellDatabaseError(p->db);\\n30687:         sqlite3_finalize(pStmt);\\n30688:         rc = 1;\\n30689:         goto meta_command_exit;\\n30690:       }\\n30691:       appendText(&sSelect, \"SELECT sql FROM\", 0);\\n30692:       iSchema = 0;\\n30693:       while( sqlite3_step(pStmt)==SQLITE_ROW ){\\n30694:         const char *zDb = (const char*)sqlite3_column_text(pStmt, 0);\\n30695:         char zScNum[30];\\n30696:         sqlite3_snprintf(sizeof(zScNum), zScNum, \"%d\", ++iSchema);\\n30697:         appendText(&sSelect, zDiv, 0);\\n30698:         zDiv = \" UNION ALL \";\\n30699:         appendText(&sSelect, \"SELECT shell_add_schema(sql,\", 0);\\n30700:         if( sqlite3_stricmp(zDb, \"main\")!=0 ){\\n30701:           appendText(&sSelect, zDb, \\'\\\\\\'\\');\\n30702:         }else{\\n30703:           appendText(&sSelect, \"NULL\", 0);\\n30704:         }\\n30705:         appendText(&sSelect, \",name) AS sql, type, tbl_name, name, rowid,\", 0);\\n30706:         appendText(&sSelect, zScNum, 0);\\n30707:         appendText(&sSelect, \" AS snum, \", 0);\\n30708:         appendText(&sSelect, zDb, \\'\\\\\\'\\');\\n30709:         appendText(&sSelect, \" AS sname FROM \", 0);\\n30710:         appendText(&sSelect, zDb, quoteChar(zDb));\\n30711:         appendText(&sSelect, \".sqlite_schema\", 0);\\n30712:       }\\n30713:       sqlite3_finalize(pStmt);\\n30714: #ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS\\n30715:       if( zName ){\\n30716:         appendText(&sSelect,\\n30717:            \" UNION ALL SELECT shell_module_schema(name),\"\\n30718:            \" \\'table\\', name, name, name, 9e+99, \\'main\\' FROM pragma_module_list\",\\n30719:         0);\\n30720:       }\\n30721: #endif\\n30722:       appendText(&sSelect, \") WHERE \", 0);\\n30723:       if( zName ){\\n30724:         char *zQarg = sqlite3_mprintf(\"%Q\", zName);\\n30725:         int bGlob;\\n30726:         shell_check_oom(zQarg);\\n30727:         bGlob = strchr(zName, \\'*\\') != 0 || strchr(zName, \\'?\\') != 0 ||\\n30728:                 strchr(zName, \\'[\\') != 0;\\n30729:         if( strchr(zName, \\'.\\') ){\\n30730:           appendText(&sSelect, \"lower(printf(\\'%s.%s\\',sname,tbl_name))\", 0);\\n30731:         }else{\\n30732:           appendText(&sSelect, \"lower(tbl_name)\", 0);\\n30733:         }\\n30734:         appendText(&sSelect, bGlob ? \" GLOB \" : \" LIKE \", 0);\\n30735:         appendText(&sSelect, zQarg, 0);\\n30736:         if( !bGlob ){\\n30737:           appendText(&sSelect, \" ESCAPE \\'\\\\\\\\\\' \", 0);\\n30738:         }\\n30739:         appendText(&sSelect, \" AND \", 0);\\n30740:         sqlite3_free(zQarg);\\n30741:       }\\n30742:       if( bNoSystemTabs ){\\n30743:         appendText(&sSelect, \"name NOT LIKE \\'sqlite_%%\\' AND \", 0);\\n30744:       }\\n30745:       appendText(&sSelect, \"sql IS NOT NULL\"\\n30746:                            \" ORDER BY snum, rowid\", 0);\\n30747:       if( bDebug ){\\n30748:         sqlite3_fprintf(p->out, \"SQL: %s;\\\\n\", sSelect.z);\\n30749:       }else{\\n30750:         rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);\\n30751:       }\\n30752:       freeText(&sSelect);\\n30753:     }\\n30754:     if( zErrMsg ){\\n30755:       shellEmitError(zErrMsg);\\n30756:       sqlite3_free(zErrMsg);\\n30757:       rc = 1;\\n30758:     }else if( rc != SQLITE_OK ){\\n30759:       eputz(\"Error: querying schema information\\\\n\");\\n30760:       rc = 1;\\n30761:     }else{\\n30762:       rc = 0;\\n30763:     }\\n30764:   }else\\n30765: \\n30766:   if( (c==\\'s\\' && n==11 && cli_strncmp(azArg[0], \"selecttrace\", n)==0)\\n30767:    || (c==\\'t\\' && n==9  && cli_strncmp(azArg[0], \"treetrace\", n)==0)\\n30768:   ){\\n30769:     unsigned int x = nArg>=2? (unsigned int)integerValue(azArg[1]) : 0xffffffff;\\n30770:     sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 1, &x);\\n30771:   }else\\n30772: \\n30773: #if defined(SQLITE_ENABLE_SESSION)\\n30774:   if( c==\\'s\\' && cli_strncmp(azArg[0],\"session\",n)==0 && n>=3 ){\\n30775:     struct AuxDb *pAuxDb = p->pAuxDb;\\n30776:     OpenSession *pSession = &pAuxDb->aSession[0];\\n30777:     char **azCmd = &azArg[1];\\n30778:     int iSes = 0;\\n30779:     int nCmd = nArg - 1;\\n30780:     int i;\\n30781:     if( nArg<=1 ) goto session_syntax_error;\\n30782:     open_db(p, 0);\\n30783:     if( nArg>=3 ){\\n30784:       for(iSes=0; iSes<pAuxDb->nSession; iSes++){\\n30785:         if( cli_strcmp(pAuxDb->aSession[iSes].zName, azArg[1])==0 ) break;\\n30786:       }\\n30787:       if( iSes<pAuxDb->nSession ){\\n30788:         pSession = &pAuxDb->aSession[iSes];\\n30789:         azCmd++;\\n30790:         nCmd--;\\n30791:       }else{\\n30792:         pSession = &pAuxDb->aSession[0];\\n30793:         iSes = 0;\\n30794:       }\\n30795:     }\\n30796: \\n30797:     /* .session attach TABLE\\n30798:     ** Invoke the sqlite3session_attach() interface to attach a particular\\n30799:     ** table so that it is never filtered.\\n30800:     */\\n30801:     if( cli_strcmp(azCmd[0],\"attach\")==0 ){\\n30802:       if( nCmd!=2 ) goto session_syntax_error;\\n30803:       if( pSession->p==0 ){\\n30804:         session_not_open:\\n30805:         eputz(\"ERROR: No sessions are open\\\\n\");\\n30806:       }else{\\n30807:         rc = sqlite3session_attach(pSession->p, azCmd[1]);\\n30808:         if( rc ){\\n30809:           sqlite3_fprintf(stderr,\\n30810:                \"ERROR: sqlite3session_attach() returns %d\\\\n\",rc);\\n30811:           rc = 0;\\n30812:         }\\n30813:       }\\n30814:     }else\\n30815: \\n30816:     /* .session changeset FILE\\n30817:     ** .session patchset FILE\\n30818:     ** Write a changeset or patchset into a file.  The file is overwritten.\\n30819:     */\\n30820:     if( cli_strcmp(azCmd[0],\"changeset\")==0\\n30821:      || cli_strcmp(azCmd[0],\"patchset\")==0\\n30822:     ){\\n30823:       FILE *out = 0;\\n30824:       failIfSafeMode(p, \"cannot run \\\\\".session %s\\\\\" in safe mode\", azCmd[0]);\\n30825:       if( nCmd!=2 ) goto session_syntax_error;\\n30826:       if( pSession->p==0 ) goto session_not_open;\\n30827:       out = sqlite3_fopen(azCmd[1], \"wb\");\\n30828:       if( out==0 ){\\n30829:         sqlite3_fprintf(stderr,\"ERROR: cannot open \\\\\"%s\\\\\" for writing\\\\n\",\\n30830:               azCmd[1]);\\n30831:       }else{\\n30832:         int szChng;\\n30833:         void *pChng;\\n30834:         if( azCmd[0][0]==\\'c\\' ){\\n30835:           rc = sqlite3session_changeset(pSession->p, &szChng, &pChng);\\n30836:         }else{\\n30837:           rc = sqlite3session_patchset(pSession->p, &szChng, &pChng);\\n30838:         }\\n30839:         if( rc ){\\n30840:           sqlite3_fprintf(stdout, \"Error: error code %d\\\\n\", rc);\\n30841:           rc = 0;\\n30842:         }\\n30843:         if( pChng\\n30844:           && fwrite(pChng, szChng, 1, out)!=1 ){\\n30845:           sqlite3_fprintf(stderr,\\n30846:               \"ERROR: Failed to write entire %d-byte output\\\\n\", szChng);\\n30847:         }\\n30848:         sqlite3_free(pChng);\\n30849:         fclose(out);\\n30850:       }\\n30851:     }else\\n30852: \\n30853:     /* .session close\\n30854:     ** Close the identified session\\n30855:     */\\n30856:     if( cli_strcmp(azCmd[0], \"close\")==0 ){\\n30857:       if( nCmd!=1 ) goto session_syntax_error;\\n30858:       if( pAuxDb->nSession ){\\n30859:         session_close(pSession);\\n30860:         pAuxDb->aSession[iSes] = pAuxDb->aSession[--pAuxDb->nSession];\\n30861:       }\\n30862:     }else\\n30863: \\n30864:     /* .session enable ?BOOLEAN?\\n30865:     ** Query or set the enable flag\\n30866:     */\\n30867:     if( cli_strcmp(azCmd[0], \"enable\")==0 ){\\n30868:       int ii;\\n30869:       if( nCmd>2 ) goto session_syntax_error;\\n30870:       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);\\n30871:       if( pAuxDb->nSession ){\\n30872:         ii = sqlite3session_enable(pSession->p, ii);\\n30873:         sqlite3_fprintf(p->out,\\n30874:             \"session %s enable flag = %d\\\\n\", pSession->zName, ii);\\n30875:       }\\n30876:     }else\\n30877: \\n30878:     /* .session filter GLOB ....\\n30879:     ** Set a list of GLOB patterns of table names to be excluded.\\n30880:     */\\n30881:     if( cli_strcmp(azCmd[0], \"filter\")==0 ){\\n30882:       int ii, nByte;\\n30883:       if( nCmd<2 ) goto session_syntax_error;\\n30884:       if( pAuxDb->nSession ){\\n30885:         for(ii=0; ii<pSession->nFilter; ii++){\\n30886:           sqlite3_free(pSession->azFilter[ii]);\\n30887:         }\\n30888:         sqlite3_free(pSession->azFilter);\\n30889:         nByte = sizeof(pSession->azFilter[0])*(nCmd-1);\\n30890:         pSession->azFilter = sqlite3_malloc( nByte );\\n30891:         shell_check_oom( pSession->azFilter );\\n30892:         for(ii=1; ii<nCmd; ii++){\\n30893:           char *x = pSession->azFilter[ii-1] = sqlite3_mprintf(\"%s\", azCmd[ii]);\\n30894:           shell_check_oom(x);\\n30895:         }\\n30896:         pSession->nFilter = ii-1;\\n30897:       }\\n30898:     }else\\n30899: \\n30900:     /* .session indirect ?BOOLEAN?\\n30901:     ** Query or set the indirect flag\\n30902:     */\\n30903:     if( cli_strcmp(azCmd[0], \"indirect\")==0 ){\\n30904:       int ii;\\n30905:       if( nCmd>2 ) goto session_syntax_error;\\n30906:       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);\\n30907:       if( pAuxDb->nSession ){\\n30908:         ii = sqlite3session_indirect(pSession->p, ii);\\n30909:         sqlite3_fprintf(p->out,\\n30910:             \"session %s indirect flag = %d\\\\n\", pSession->zName, ii);\\n30911:       }\\n30912:     }else\\n30913: \\n30914:     /* .session isempty\\n30915:     ** Determine if the session is empty\\n30916:     */\\n30917:     if( cli_strcmp(azCmd[0], \"isempty\")==0 ){\\n30918:       int ii;\\n30919:       if( nCmd!=1 ) goto session_syntax_error;\\n30920:       if( pAuxDb->nSession ){\\n30921:         ii = sqlite3session_isempty(pSession->p);\\n30922:         sqlite3_fprintf(p->out,\\n30923:              \"session %s isempty flag = %d\\\\n\", pSession->zName, ii);\\n30924:       }\\n30925:     }else\\n30926: \\n30927:     /* .session list\\n30928:     ** List all currently open sessions\\n30929:     */\\n30930:     if( cli_strcmp(azCmd[0],\"list\")==0 ){\\n30931:       for(i=0; i<pAuxDb->nSession; i++){\\n30932:         sqlite3_fprintf(p->out, \"%d %s\\\\n\", i, pAuxDb->aSession[i].zName);\\n30933:       }\\n30934:     }else\\n30935: \\n30936:     /* .session open DB NAME\\n30937:     ** Open a new session called NAME on the attached database DB.\\n30938:     ** DB is normally \"main\".\\n30939:     */\\n30940:     if( cli_strcmp(azCmd[0],\"open\")==0 ){\\n30941:       char *zName;\\n30942:       if( nCmd!=3 ) goto session_syntax_error;\\n30943:       zName = azCmd[2];\\n30944:       if( zName[0]==0 ) goto session_syntax_error;\\n30945:       for(i=0; i<pAuxDb->nSession; i++){\\n30946:         if( cli_strcmp(pAuxDb->aSession[i].zName,zName)==0 ){\\n30947:           sqlite3_fprintf(stderr,\"Session \\\\\"%s\\\\\" already exists\\\\n\", zName);\\n30948:           goto meta_command_exit;\\n30949:         }\\n30950:       }\\n30951:       if( pAuxDb->nSession>=ArraySize(pAuxDb->aSession) ){\\n30952:         sqlite3_fprintf(stderr,\\n30953:            \"Maximum of %d sessions\\\\n\", ArraySize(pAuxDb->aSession));\\n30954:         goto meta_command_exit;\\n30955:       }\\n30956:       pSession = &pAuxDb->aSession[pAuxDb->nSession];\\n30957:       rc = sqlite3session_create(p->db, azCmd[1], &pSession->p);\\n30958:       if( rc ){\\n30959:         sqlite3_fprintf(stderr,\"Cannot open session: error code=%d\\\\n\", rc);\\n30960:         rc = 0;\\n30961:         goto meta_command_exit;\\n30962:       }\\n30963:       pSession->nFilter = 0;\\n30964:       sqlite3session_table_filter(pSession->p, session_filter, pSession);\\n30965:       pAuxDb->nSession++;\\n30966:       pSession->zName = sqlite3_mprintf(\"%s\", zName);\\n30967:       shell_check_oom(pSession->zName);\\n30968:     }else\\n30969:     /* If no command name matches, show a syntax error */\\n30970:     session_syntax_error:\\n30971:     showHelp(p->out, \"session\");\\n30972:   }else\\n30973: #endif\\n30974: \\n30975: #ifdef SQLITE_DEBUG\\n30976:   /* Undocumented commands for internal testing.  Subject to change\\n30977:   ** without notice. */\\n30978:   if( c==\\'s\\' && n>=10 && cli_strncmp(azArg[0], \"selftest-\", 9)==0 ){\\n30979:     if( cli_strncmp(azArg[0]+9, \"boolean\", n-9)==0 ){\\n30980:       int i, v;\\n30981:       for(i=1; i<nArg; i++){\\n30982:         v = booleanValue(azArg[i]);\\n30983:         sqlite3_fprintf(p->out, \"%s: %d 0x%x\\\\n\", azArg[i], v, v);\\n30984:       }\\n30985:     }\\n30986:     if( cli_strncmp(azArg[0]+9, \"integer\", n-9)==0 ){\\n30987:       int i; sqlite3_int64 v;\\n30988:       for(i=1; i<nArg; i++){\\n30989:         char zBuf[200];\\n30990:         v = integerValue(azArg[i]);\\n30991:         sqlite3_snprintf(sizeof(zBuf),zBuf,\"%s: %lld 0x%llx\\\\n\", azArg[i],v,v);\\n30992:         sqlite3_fputs(zBuf, p->out);\\n30993:       }\\n30994:     }\\n30995:   }else\\n30996: #endif\\n30997: \\n30998:   if( c==\\'s\\' && n>=4 && cli_strncmp(azArg[0],\"selftest\",n)==0 ){\\n30999:     int bIsInit = 0;         /* True to initialize the SELFTEST table */\\n31000:     int bVerbose = 0;        /* Verbose output */\\n31001:     int bSelftestExists;     /* True if SELFTEST already exists */\\n31002:     int i, k;                /* Loop counters */\\n31003:     int nTest = 0;           /* Number of tests runs */\\n31004:     int nErr = 0;            /* Number of errors seen */\\n31005:     ShellText str;           /* Answer for a query */\\n31006:     sqlite3_stmt *pStmt = 0; /* Query against the SELFTEST table */\\n31007: \\n31008:     open_db(p,0);\\n31009:     for(i=1; i<nArg; i++){\\n31010:       const char *z = azArg[i];\\n31011:       if( z[0]==\\'-\\' && z[1]==\\'-\\' ) z++;\\n31012:       if( cli_strcmp(z,\"-init\")==0 ){\\n31013:         bIsInit = 1;\\n31014:       }else\\n31015:       if( cli_strcmp(z,\"-v\")==0 ){\\n31016:         bVerbose++;\\n31017:       }else\\n31018:       {\\n31019:         sqlite3_fprintf(stderr,\\n31020:               \"Unknown option \\\\\"%s\\\\\" on \\\\\"%s\\\\\"\\\\n\", azArg[i], azArg[0]);\\n31021:         sqlite3_fputs(\"Should be one of: --init -v\\\\n\", stderr);\\n31022:         rc = 1;\\n31023:         goto meta_command_exit;\\n31024:       }\\n31025:     }\\n31026:     if( sqlite3_table_column_metadata(p->db,\"main\",\"selftest\",0,0,0,0,0,0)\\n31027:            != SQLITE_OK ){\\n31028:       bSelftestExists = 0;\\n31029:     }else{\\n31030:       bSelftestExists = 1;\\n31031:     }\\n31032:     if( bIsInit ){\\n31033:       createSelftestTable(p);\\n31034:       bSelftestExists = 1;\\n31035:     }\\n31036:     initText(&str);\\n31037:     appendText(&str, \"x\", 0);\\n31038:     for(k=bSelftestExists; k>=0; k--){\\n31039:       if( k==1 ){\\n31040:         rc = sqlite3_prepare_v2(p->db,\\n31041:             \"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\",\\n31042:             -1, &pStmt, 0);\\n31043:       }else{\\n31044:         rc = sqlite3_prepare_v2(p->db,\\n31045:           \"VALUES(0,\\'memo\\',\\'Missing SELFTEST table - default checks only\\',\\'\\'),\"\\n31046:           \"      (1,\\'run\\',\\'PRAGMA integrity_check\\',\\'ok\\')\",\\n31047:           -1, &pStmt, 0);\\n31048:       }\\n31049:       if( rc ){\\n31050:         eputz(\"Error querying the selftest table\\\\n\");\\n31051:         rc = 1;\\n31052:         sqlite3_finalize(pStmt);\\n31053:         goto meta_command_exit;\\n31054:       }\\n31055:       for(i=1; sqlite3_step(pStmt)==SQLITE_ROW; i++){\\n31056:         int tno = sqlite3_column_int(pStmt, 0);\\n31057:         const char *zOp = (const char*)sqlite3_column_text(pStmt, 1);\\n31058:         const char *zSql = (const char*)sqlite3_column_text(pStmt, 2);\\n31059:         const char *zAns = (const char*)sqlite3_column_text(pStmt, 3);\\n31060: \\n31061:         if( zOp==0 ) continue;\\n31062:         if( zSql==0 ) continue;\\n31063:         if( zAns==0 ) continue;\\n31064:         k = 0;\\n31065:         if( bVerbose>0 ){\\n31066:           sqlite3_fprintf(stdout, \"%d: %s %s\\\\n\", tno, zOp, zSql);\\n31067:         }\\n31068:         if( cli_strcmp(zOp,\"memo\")==0 ){\\n31069:           sqlite3_fprintf(p->out, \"%s\\\\n\", zSql);\\n31070:         }else\\n31071:         if( cli_strcmp(zOp,\"run\")==0 ){\\n31072:           char *zErrMsg = 0;\\n31073:           str.n = 0;\\n31074:           str.z[0] = 0;\\n31075:           rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);\\n31076:           nTest++;\\n31077:           if( bVerbose ){\\n31078:             sqlite3_fprintf(p->out, \"Result: %s\\\\n\", str.z);\\n31079:           }\\n31080:           if( rc || zErrMsg ){\\n31081:             nErr++;\\n31082:             rc = 1;\\n31083:             sqlite3_fprintf(p->out, \"%d: error-code-%d: %s\\\\n\", tno, rc,zErrMsg);\\n31084:             sqlite3_free(zErrMsg);\\n31085:           }else if( cli_strcmp(zAns,str.z)!=0 ){\\n31086:             nErr++;\\n31087:             rc = 1;\\n31088:             sqlite3_fprintf(p->out, \"%d: Expected: [%s]\\\\n\", tno, zAns);\\n31089:             sqlite3_fprintf(p->out, \"%d:      Got: [%s]\\\\n\", tno, str.z);\\n31090:           }\\n31091:         }\\n31092:         else{\\n31093:           sqlite3_fprintf(stderr,\\n31094:                 \"Unknown operation \\\\\"%s\\\\\" on selftest line %d\\\\n\", zOp, tno);\\n31095:           rc = 1;\\n31096:           break;\\n31097:         }\\n31098:       } /* End loop over rows of content from SELFTEST */\\n31099:       sqlite3_finalize(pStmt);\\n31100:     } /* End loop over k */\\n31101:     freeText(&str);\\n31102:     sqlite3_fprintf(p->out, \"%d errors out of %d tests\\\\n\", nErr, nTest);\\n31103:   }else\\n31104: \\n31105:   if( c==\\'s\\' && cli_strncmp(azArg[0], \"separator\", n)==0 ){\\n31106:     if( nArg<2 || nArg>3 ){\\n31107:       eputz(\"Usage: .separator COL ?ROW?\\\\n\");\\n31108:       rc = 1;\\n31109:     }\\n31110:     if( nArg>=2 ){\\n31111:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator,\\n31112:                        \"%.*s\", (int)ArraySize(p->colSeparator)-1, azArg[1]);\\n31113:     }\\n31114:     if( nArg>=3 ){\\n31115:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator,\\n31116:                        \"%.*s\", (int)ArraySize(p->rowSeparator)-1, azArg[2]);\\n31117:     }\\n31118:   }else\\n31119: \\n31120:   if( c==\\'s\\' && n>=4 && cli_strncmp(azArg[0],\"sha3sum\",n)==0 ){\\n31121:     const char *zLike = 0;   /* Which table to checksum. 0 means everything */\\n31122:     int i;                   /* Loop counter */\\n31123:     int bSchema = 0;         /* Also hash the schema */\\n31124:     int bSeparate = 0;       /* Hash each table separately */\\n31125:     int iSize = 224;         /* Hash algorithm to use */\\n31126:     int bDebug = 0;          /* Only show the query that would have run */\\n31127:     sqlite3_stmt *pStmt;     /* For querying tables names */\\n31128:     char *zSql;              /* SQL to be run */\\n31129:     char *zSep;              /* Separator */\\n31130:     ShellText sSql;          /* Complete SQL for the query to run the hash */\\n31131:     ShellText sQuery;        /* Set of queries used to read all content */\\n31132:     open_db(p, 0);\\n31133:     for(i=1; i<nArg; i++){\\n31134:       const char *z = azArg[i];\\n31135:       if( z[0]==\\'-\\' ){\\n31136:         z++;\\n31137:         if( z[0]==\\'-\\' ) z++;\\n31138:         if( cli_strcmp(z,\"schema\")==0 ){\\n31139:           bSchema = 1;\\n31140:         }else\\n31141:         if( cli_strcmp(z,\"sha3-224\")==0 || cli_strcmp(z,\"sha3-256\")==0\\n31142:          || cli_strcmp(z,\"sha3-384\")==0 || cli_strcmp(z,\"sha3-512\")==0\\n31143:         ){\\n31144:           iSize = atoi(&z[5]);\\n31145:         }else\\n31146:         if( cli_strcmp(z,\"debug\")==0 ){\\n31147:           bDebug = 1;\\n31148:         }else\\n31149:         {\\n31150:           sqlite3_fprintf(stderr,\\n31151:                   \"Unknown option \\\\\"%s\\\\\" on \\\\\"%s\\\\\"\\\\n\", azArg[i], azArg[0]);\\n31152:           showHelp(p->out, azArg[0]);\\n31153:           rc = 1;\\n31154:           goto meta_command_exit;\\n31155:         }\\n31156:       }else if( zLike ){\\n31157:         eputz(\"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\\\\n\");\\n31158:         rc = 1;\\n31159:         goto meta_command_exit;\\n31160:       }else{\\n31161:         zLike = z;\\n31162:         bSeparate = 1;\\n31163:         if( sqlite3_strlike(\"sqlite\\\\\\\\_%\", zLike, \\'\\\\\\\\\\')==0 ) bSchema = 1;\\n31164:       }\\n31165:     }\\n31166:     if( bSchema ){\\n31167:       zSql = \"SELECT lower(name) as tname FROM sqlite_schema\"\\n31168:              \" WHERE type=\\'table\\' AND coalesce(rootpage,0)>1\"\\n31169:              \" UNION ALL SELECT \\'sqlite_schema\\'\"\\n31170:              \" ORDER BY 1 collate nocase\";\\n31171:     }else{\\n31172:       zSql = \"SELECT lower(name) as tname FROM sqlite_schema\"\\n31173:              \" WHERE type=\\'table\\' AND coalesce(rootpage,0)>1\"\\n31174:              \" AND name NOT LIKE \\'sqlite_%\\'\"\\n31175:              \" ORDER BY 1 collate nocase\";\\n31176:     }\\n31177:     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\\n31178:     initText(&sQuery);\\n31179:     initText(&sSql);\\n31180:     appendText(&sSql, \"WITH [sha3sum$query](a,b) AS(\",0);\\n31181:     zSep = \"VALUES(\";\\n31182:     while( SQLITE_ROW==sqlite3_step(pStmt) ){\\n31183:       const char *zTab = (const char*)sqlite3_column_text(pStmt,0);\\n31184:       if( zTab==0 ) continue;\\n31185:       if( zLike && sqlite3_strlike(zLike, zTab, 0)!=0 ) continue;\\n31186:       if( cli_strncmp(zTab, \"sqlite_\",7)!=0 ){\\n31187:         appendText(&sQuery,\"SELECT * FROM \", 0);\\n31188:         appendText(&sQuery,zTab,\\'\"\\');\\n31189:         appendText(&sQuery,\" NOT INDEXED;\", 0);\\n31190:       }else if( cli_strcmp(zTab, \"sqlite_schema\")==0 ){\\n31191:         appendText(&sQuery,\"SELECT type,name,tbl_name,sql FROM sqlite_schema\"\\n31192:                            \" ORDER BY name;\", 0);\\n31193:       }else if( cli_strcmp(zTab, \"sqlite_sequence\")==0 ){\\n31194:         appendText(&sQuery,\"SELECT name,seq FROM sqlite_sequence\"\\n31195:                            \" ORDER BY name;\", 0);\\n31196:       }else if( cli_strcmp(zTab, \"sqlite_stat1\")==0 ){\\n31197:         appendText(&sQuery,\"SELECT tbl,idx,stat FROM sqlite_stat1\"\\n31198:                            \" ORDER BY tbl,idx;\", 0);\\n31199:       }else if( cli_strcmp(zTab, \"sqlite_stat4\")==0 ){\\n31200:         appendText(&sQuery, \"SELECT * FROM \", 0);\\n31201:         appendText(&sQuery, zTab, 0);\\n31202:         appendText(&sQuery, \" ORDER BY tbl, idx, rowid;\\\\n\", 0);\\n31203:       }\\n31204:       appendText(&sSql, zSep, 0);\\n31205:       appendText(&sSql, sQuery.z, \\'\\\\\\'\\');\\n31206:       sQuery.n = 0;\\n31207:       appendText(&sSql, \",\", 0);\\n31208:       appendText(&sSql, zTab, \\'\\\\\\'\\');\\n31209:       zSep = \"),(\";\\n31210:     }\\n31211:     sqlite3_finalize(pStmt);\\n31212:     if( bSeparate ){\\n31213:       zSql = sqlite3_mprintf(\\n31214:           \"%s))\"\\n31215:           \" SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label\"\\n31216:           \"   FROM [sha3sum$query]\",\\n31217:           sSql.z, iSize);\\n31218:     }else{\\n31219:       zSql = sqlite3_mprintf(\\n31220:           \"%s))\"\\n31221:           \" SELECT lower(hex(sha3_query(group_concat(a,\\'\\'),%d))) AS hash\"\\n31222:           \"   FROM [sha3sum$query]\",\\n31223:           sSql.z, iSize);\\n31224:     }\\n31225:     shell_check_oom(zSql);\\n31226:     freeText(&sQuery);\\n31227:     freeText(&sSql);\\n31228:     if( bDebug ){\\n31229:       sqlite3_fprintf(p->out, \"%s\\\\n\", zSql);\\n31230:     }else{\\n31231:       shell_exec(p, zSql, 0);\\n31232:     }\\n31233: #if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS) && !defined(SQLITE_OMIT_VIRTUALTABLE)\\n31234:     {\\n31235:       int lrc;\\n31236:       char *zRevText = /* Query for reversible to-blob-to-text check */\\n31237:         \"SELECT lower(name) as tname FROM sqlite_schema\\\\n\"\\n31238:         \"WHERE type=\\'table\\' AND coalesce(rootpage,0)>1\\\\n\"\\n31239:         \"AND name NOT LIKE \\'sqlite_%%\\'%s\\\\n\"\\n31240:         \"ORDER BY 1 collate nocase\";\\n31241:       zRevText = sqlite3_mprintf(zRevText, zLike? \" AND name LIKE $tspec\" : \"\");\\n31242:       zRevText = sqlite3_mprintf(\\n31243:           /* lower-case query is first run, producing upper-case query. */\\n31244:           \"with tabcols as materialized(\\\\n\"\\n31245:           \"select tname, cname\\\\n\"\\n31246:           \"from (\"\\n31247:           \" select printf(\\'\\\\\"%%w\\\\\"\\',ss.tname) as tname,\"\\n31248:           \" printf(\\'\\\\\"%%w\\\\\"\\',ti.name) as cname\\\\n\"\\n31249:           \" from (%z) ss\\\\n inner join pragma_table_info(tname) ti))\\\\n\"\\n31250:           \"select \\'SELECT total(bad_text_count) AS bad_text_count\\\\n\"\\n31251:           \"FROM (\\'||group_concat(query, \\' UNION ALL \\')||\\')\\' as btc_query\\\\n\"\\n31252:           \" from (select \\'SELECT COUNT(*) AS bad_text_count\\\\n\"\\n31253:           \"FROM \\'||tname||\\' WHERE \\'\\\\n\"\\n31254:           \"||group_concat(\\'CAST(CAST(\\'||cname||\\' AS BLOB) AS TEXT)<>\\'||cname\\\\n\"\\n31255:           \"|| \\' AND typeof(\\'||cname||\\')=\\'\\'text\\'\\' \\',\\\\n\"\\n31256:           \"\\' OR \\') as query, tname from tabcols group by tname)\"\\n31257:           , zRevText);\\n31258:       shell_check_oom(zRevText);\\n31259:       if( bDebug ) sqlite3_fprintf(p->out, \"%s\\\\n\", zRevText);\\n31260:       lrc = sqlite3_prepare_v2(p->db, zRevText, -1, &pStmt, 0);\\n31261:       if( lrc!=SQLITE_OK ){\\n31262:         /* assert(lrc==SQLITE_NOMEM); // might also be SQLITE_ERROR if the\\n31263:         ** user does cruel and unnatural things like \".limit expr_depth 0\". */\\n31264:         rc = 1;\\n31265:       }else{\\n31266:         if( zLike ) sqlite3_bind_text(pStmt,1,zLike,-1,SQLITE_STATIC);\\n31267:         lrc = SQLITE_ROW==sqlite3_step(pStmt);\\n31268:         if( lrc ){\\n31269:           const char *zGenQuery = (char*)sqlite3_column_text(pStmt,0);\\n31270:           sqlite3_stmt *pCheckStmt;\\n31271:           lrc = sqlite3_prepare_v2(p->db, zGenQuery, -1, &pCheckStmt, 0);\\n31272:           if( bDebug ) sqlite3_fprintf(p->out, \"%s\\\\n\", zGenQuery);\\n31273:           if( lrc!=SQLITE_OK ){\\n31274:             rc = 1;\\n31275:           }else{\\n31276:             if( SQLITE_ROW==sqlite3_step(pCheckStmt) ){\\n31277:               double countIrreversible = sqlite3_column_double(pCheckStmt, 0);\\n31278:               if( countIrreversible>0 ){\\n31279:                 int sz = (int)(countIrreversible + 0.5);\\n31280:                 sqlite3_fprintf(stderr,\\n31281:                       \"Digest includes %d invalidly encoded text field%s.\\\\n\",\\n31282:                       sz, (sz>1)? \"s\": \"\");\\n31283:               }\\n31284:             }\\n31285:             sqlite3_finalize(pCheckStmt);\\n31286:           }\\n31287:           sqlite3_finalize(pStmt);\\n31288:         }\\n31289:       }\\n31290:       if( rc ) eputz(\".sha3sum failed.\\\\n\");\\n31291:       sqlite3_free(zRevText);\\n31292:     }\\n31293: #endif /* !defined(*_OMIT_SCHEMA_PRAGMAS) && !defined(*_OMIT_VIRTUALTABLE) */\\n31294:     sqlite3_free(zSql);\\n31295:   }else\\n31296: \\n31297: #if !defined(SQLITE_NOHAVE_SYSTEM) && !defined(SQLITE_SHELL_FIDDLE)\\n31298:   if( c==\\'s\\'\\n31299:    && (cli_strncmp(azArg[0], \"shell\", n)==0\\n31300:        || cli_strncmp(azArg[0],\"system\",n)==0)\\n31301:   ){\\n31302:     char *zCmd;\\n31303:     int i, x;\\n31304:     failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\\n31305:     if( nArg<2 ){\\n31306:       eputz(\"Usage: .system COMMAND\\\\n\");\\n31307:       rc = 1;\\n31308:       goto meta_command_exit;\\n31309:     }\\n31310:     zCmd = sqlite3_mprintf(strchr(azArg[1],\\' \\')==0?\"%s\":\"\\\\\"%s\\\\\"\", azArg[1]);\\n31311:     for(i=2; i<nArg && zCmd!=0; i++){\\n31312:       zCmd = sqlite3_mprintf(strchr(azArg[i],\\' \\')==0?\"%z %s\":\"%z \\\\\"%s\\\\\"\",\\n31313:                              zCmd, azArg[i]);\\n31314:     }\\n31315:     /*consoleRestore();*/\\n31316:     x = zCmd!=0 ? system(zCmd) : 1;\\n31317:     /*consoleRenewSetup();*/\\n31318:     sqlite3_free(zCmd);\\n31319:     if( x ) sqlite3_fprintf(stderr,\"System command returns %d\\\\n\", x);\\n31320:   }else\\n31321: #endif /* !defined(SQLITE_NOHAVE_SYSTEM) && !defined(SQLITE_SHELL_FIDDLE) */\\n31322: \\n31323:   if( c==\\'s\\' && cli_strncmp(azArg[0], \"show\", n)==0 ){\\n31324:     static const char *azBool[] = { \"off\", \"on\", \"trigger\", \"full\"};\\n31325:     const char *zOut;\\n31326:     int i;\\n31327:     if( nArg!=1 ){\\n31328:       eputz(\"Usage: .show\\\\n\");\\n31329:       rc = 1;\\n31330:       goto meta_command_exit;\\n31331:     }\\n31332:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"echo\",\\n31333:           azBool[ShellHasFlag(p, SHFLG_Echo)]);\\n31334:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"eqp\", azBool[p->autoEQP&3]);\\n31335:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"explain\",\\n31336:           p->mode==MODE_Explain ? \"on\" : p->autoExplain ? \"auto\" : \"off\");\\n31337:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"headers\",\\n31338:           azBool[p->showHeader!=0]);\\n31339:     if( p->mode==MODE_Column\\n31340:      || (p->mode>=MODE_Markdown && p->mode<=MODE_Box)\\n31341:     ){\\n31342:       sqlite3_fprintf(p->out,\\n31343:             \"%12.12s: %s --wrap %d --wordwrap %s --%squote\\\\n\", \"mode\",\\n31344:             modeDescr[p->mode], p->cmOpts.iWrap,\\n31345:             p->cmOpts.bWordWrap ? \"on\" : \"off\",\\n31346:             p->cmOpts.bQuote ? \"\" : \"no\");\\n31347:     }else{\\n31348:       sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"mode\", modeDescr[p->mode]);\\n31349:     }\\n31350:     sqlite3_fprintf(p->out, \"%12.12s: \", \"nullvalue\");\\n31351:     output_c_string(p->out, p->nullValue);\\n31352:     sqlite3_fputs(\"\\\\n\", p->out);\\n31353:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"output\",\\n31354:           strlen30(p->outfile) ? p->outfile : \"stdout\");\\n31355:     sqlite3_fprintf(p->out, \"%12.12s: \", \"colseparator\");\\n31356:     output_c_string(p->out, p->colSeparator);\\n31357:     sqlite3_fputs(\"\\\\n\", p->out);\\n31358:     sqlite3_fprintf(p->out, \"%12.12s: \", \"rowseparator\");\\n31359:     output_c_string(p->out, p->rowSeparator);\\n31360:     sqlite3_fputs(\"\\\\n\", p->out);\\n31361:     switch( p->statsOn ){\\n31362:       case 0:  zOut = \"off\";     break;\\n31363:       default: zOut = \"on\";      break;\\n31364:       case 2:  zOut = \"stmt\";    break;\\n31365:       case 3:  zOut = \"vmstep\";  break;\\n31366:     }\\n31367:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\",\"stats\", zOut);\\n31368:     sqlite3_fprintf(p->out, \"%12.12s: \", \"width\");\\n31369:     for (i=0;i<p->nWidth;i++) {\\n31370:       sqlite3_fprintf(p->out, \"%d \", p->colWidth[i]);\\n31371:     }\\n31372:     sqlite3_fputs(\"\\\\n\", p->out);\\n31373:     sqlite3_fprintf(p->out, \"%12.12s: %s\\\\n\", \"filename\",\\n31374:           p->pAuxDb->zDbFilename ? p->pAuxDb->zDbFilename : \"\");\\n31375:   }else\\n31376: \\n31377:   if( c==\\'s\\' && cli_strncmp(azArg[0], \"stats\", n)==0 ){\\n31378:     if( nArg==2 ){\\n31379:       if( cli_strcmp(azArg[1],\"stmt\")==0 ){\\n31380:         p->statsOn = 2;\\n31381:       }else if( cli_strcmp(azArg[1],\"vmstep\")==0 ){\\n31382:         p->statsOn = 3;\\n31383:       }else{\\n31384:         p->statsOn = (u8)booleanValue(azArg[1]);\\n31385:       }\\n31386:     }else if( nArg==1 ){\\n31387:       display_stats(p->db, p, 0);\\n31388:     }else{\\n31389:       eputz(\"Usage: .stats ?on|off|stmt|vmstep?\\\\n\");\\n31390:       rc = 1;\\n31391:     }\\n31392:   }else\\n31393: \\n31394:   if( (c==\\'t\\' && n>1 && cli_strncmp(azArg[0], \"tables\", n)==0)\\n31395:    || (c==\\'i\\' && (cli_strncmp(azArg[0], \"indices\", n)==0\\n31396:                  || cli_strncmp(azArg[0], \"indexes\", n)==0) )\\n31397:   ){\\n31398:     sqlite3_stmt *pStmt;\\n31399:     char **azResult;\\n31400:     int nRow, nAlloc;\\n31401:     int ii;\\n31402:     ShellText s;\\n31403:     initText(&s);\\n31404:     open_db(p, 0);\\n31405:     rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\\n31406:     if( rc ){\\n31407:       sqlite3_finalize(pStmt);\\n31408:       return shellDatabaseError(p->db);\\n31409:     }\\n31410: \\n31411:     if( nArg>2 && c==\\'i\\' ){\\n31412:       /* It is an historical accident that the .indexes command shows an error\\n31413:       ** when called with the wrong number of arguments whereas the .tables\\n31414:       ** command does not. */\\n31415:       eputz(\"Usage: .indexes ?LIKE-PATTERN?\\\\n\");\\n31416:       rc = 1;\\n31417:       sqlite3_finalize(pStmt);\\n31418:       goto meta_command_exit;\\n31419:     }\\n31420:     for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++){\\n31421:       const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);\\n31422:       if( zDbName==0 ) continue;\\n31423:       if( s.z && s.z[0] ) appendText(&s, \" UNION ALL \", 0);\\n31424:       if( sqlite3_stricmp(zDbName, \"main\")==0 ){\\n31425:         appendText(&s, \"SELECT name FROM \", 0);\\n31426:       }else{\\n31427:         appendText(&s, \"SELECT \", 0);\\n31428:         appendText(&s, zDbName, \\'\\\\\\'\\');\\n31429:         appendText(&s, \"||\\'.\\'||name FROM \", 0);\\n31430:       }\\n31431:       appendText(&s, zDbName, \\'\"\\');\\n31432:       appendText(&s, \".sqlite_schema \", 0);\\n31433:       if( c==\\'t\\' ){\\n31434:         appendText(&s,\" WHERE type IN (\\'table\\',\\'view\\')\"\\n31435:                       \"   AND name NOT LIKE \\'sqlite_%\\'\"\\n31436:                       \"   AND name LIKE ?1\", 0);\\n31437:       }else{\\n31438:         appendText(&s,\" WHERE type=\\'index\\'\"\\n31439:                       \"   AND tbl_name LIKE ?1\", 0);\\n31440:       }\\n31441:     }\\n31442:     rc = sqlite3_finalize(pStmt);\\n31443:     if( rc==SQLITE_OK ){\\n31444:       appendText(&s, \" ORDER BY 1\", 0);\\n31445:       rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);\\n31446:     }\\n31447:     freeText(&s);\\n31448:     if( rc ) return shellDatabaseError(p->db);\\n31449: \\n31450:     /* Run the SQL statement prepared by the above block. Store the results\\n31451:     ** as an array of nul-terminated strings in azResult[].  */\\n31452:     nRow = nAlloc = 0;\\n31453:     azResult = 0;\\n31454:     if( nArg>1 ){\\n31455:       sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);\\n31456:     }else{\\n31457:       sqlite3_bind_text(pStmt, 1, \"%\", -1, SQLITE_STATIC);\\n31458:     }\\n31459:     while( sqlite3_step(pStmt)==SQLITE_ROW ){\\n31460:       if( nRow>=nAlloc ){\\n31461:         char **azNew;\\n31462:         int n2 = nAlloc*2 + 10;\\n31463:         azNew = sqlite3_realloc64(azResult, sizeof(azResult[0])*n2);\\n31464:         shell_check_oom(azNew);\\n31465:         nAlloc = n2;\\n31466:         azResult = azNew;\\n31467:       }\\n31468:       azResult[nRow] = sqlite3_mprintf(\"%s\", sqlite3_column_text(pStmt, 0));\\n31469:       shell_check_oom(azResult[nRow]);\\n31470:       nRow++;\\n31471:     }\\n31472:     if( sqlite3_finalize(pStmt)!=SQLITE_OK ){\\n31473:       rc = shellDatabaseError(p->db);\\n31474:     }\\n31475: \\n31476:     /* Pretty-print the contents of array azResult[] to the output */\\n31477:     if( rc==0 && nRow>0 ){\\n31478:       int len, maxlen = 0;\\n31479:       int i, j;\\n31480:       int nPrintCol, nPrintRow;\\n31481:       for(i=0; i<nRow; i++){\\n31482:         len = strlen30(azResult[i]);\\n31483:         if( len>maxlen ) maxlen = len;\\n31484:       }\\n31485:       nPrintCol = 80/(maxlen+2);\\n31486:       if( nPrintCol<1 ) nPrintCol = 1;\\n31487:       nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\\n31488:       for(i=0; i<nPrintRow; i++){\\n31489:         for(j=i; j<nRow; j+=nPrintRow){\\n31490:           char *zSp = j<nPrintRow ? \"\" : \"  \";\\n31491:           sqlite3_fprintf(p->out,\\n31492:                \"%s%-*s\", zSp, maxlen, azResult[j] ? azResult[j]:\"\");\\n31493:         }\\n31494:         sqlite3_fputs(\"\\\\n\", p->out);\\n31495:       }\\n31496:     }\\n31497: \\n31498:     for(ii=0; ii<nRow; ii++) sqlite3_free(azResult[ii]);\\n31499:     sqlite3_free(azResult);\\n31500:   }else\\n31501: \\n31502: #ifndef SQLITE_SHELL_FIDDLE\\n31503:   /* Begin redirecting output to the file \"testcase-out.txt\" */\\n31504:   if( c==\\'t\\' && cli_strcmp(azArg[0],\"testcase\")==0 ){\\n31505:     output_reset(p);\\n31506:     p->out = output_file_open(\"testcase-out.txt\");\\n31507:     if( p->out==0 ){\\n31508:       eputz(\"Error: cannot open \\'testcase-out.txt\\'\\\\n\");\\n31509:     }\\n31510:     if( nArg>=2 ){\\n31511:       sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, \"%s\", azArg[1]);\\n31512:     }else{\\n31513:       sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, \"?\");\\n31514:     }\\n31515:   }else\\n31516: #endif /* !defined(SQLITE_SHELL_FIDDLE) */\\n31517: \\n31518: #ifndef SQLITE_UNTESTABLE\\n31519:   if( c==\\'t\\' && n>=8 && cli_strncmp(azArg[0], \"testctrl\", n)==0 ){\\n31520:     static const struct {\\n31521:        const char *zCtrlName;   /* Name of a test-control option */\\n31522:        int ctrlCode;            /* Integer code for that option */\\n31523:        int unSafe;              /* Not valid unless --unsafe-testing */\\n31524:        const char *zUsage;      /* Usage notes */\\n31525:     } aCtrl[] = {\\n31526:     {\"always\",             SQLITE_TESTCTRL_ALWAYS, 1,     \"BOOLEAN\"         },\\n31527:     {\"assert\",             SQLITE_TESTCTRL_ASSERT, 1,     \"BOOLEAN\"         },\\n31528:   /*{\"benign_malloc_hooks\",SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,1, \"\"        },*/\\n31529:   /*{\"bitvec_test\",        SQLITE_TESTCTRL_BITVEC_TEST, 1,  \"\"              },*/\\n31530:     {\"byteorder\",          SQLITE_TESTCTRL_BYTEORDER, 0,  \"\"                },\\n31531:     {\"extra_schema_checks\",SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS,0,\"BOOLEAN\"  },\\n31532:     {\"fault_install\",      SQLITE_TESTCTRL_FAULT_INSTALL, 1,\"args...\"       },\\n31533:     {\"fk_no_action\",       SQLITE_TESTCTRL_FK_NO_ACTION, 0, \"BOOLEAN\"       },\\n31534:     {\"imposter\",         SQLITE_TESTCTRL_IMPOSTER,1,\"SCHEMA ON/OFF ROOTPAGE\"},\\n31535:     {\"internal_functions\", SQLITE_TESTCTRL_INTERNAL_FUNCTIONS,0,\"\"          },\\n31536:     {\"json_selfcheck\",     SQLITE_TESTCTRL_JSON_SELFCHECK ,0,\"BOOLEAN\"      },\\n31537:     {\"localtime_fault\",    SQLITE_TESTCTRL_LOCALTIME_FAULT,0,\"BOOLEAN\"      },\\n31538:     {\"never_corrupt\",      SQLITE_TESTCTRL_NEVER_CORRUPT,1, \"BOOLEAN\"       },\\n31539:     {\"optimizations\",      SQLITE_TESTCTRL_OPTIMIZATIONS,0,\"DISABLE-MASK ...\"},\\n31540: #ifdef YYCOVERAGE\\n31541:     {\"parser_coverage\",    SQLITE_TESTCTRL_PARSER_COVERAGE,0,\"\"             },\\n31542: #endif\\n31543:     {\"pending_byte\",       SQLITE_TESTCTRL_PENDING_BYTE,1, \"OFFSET  \"       },\\n31544:     {\"prng_restore\",       SQLITE_TESTCTRL_PRNG_RESTORE,0, \"\"               },\\n31545:     {\"prng_save\",          SQLITE_TESTCTRL_PRNG_SAVE,   0, \"\"               },\\n31546:     {\"prng_seed\",          SQLITE_TESTCTRL_PRNG_SEED,   0, \"SEED ?db?\"      },\\n31547:     {\"seek_count\",         SQLITE_TESTCTRL_SEEK_COUNT,  0, \"\"               },\\n31548:     {\"sorter_mmap\",        SQLITE_TESTCTRL_SORTER_MMAP, 0, \"NMAX\"           },\\n31549:     {\"tune\",               SQLITE_TESTCTRL_TUNE,        1, \"ID VALUE\"       },\\n31550:     };\\n31551:     int testctrl = -1;\\n31552:     int iCtrl = -1;\\n31553:     int rc2 = 0;    /* 0: usage.  1: %d  2: %x  3: no-output */\\n31554:     int isOk = 0;\\n31555:     int i, n2;\\n31556:     const char *zCmd = 0;\\n31557: \\n31558:     open_db(p, 0);\\n31559:     zCmd = nArg>=2 ? azArg[1] : \"help\";\\n31560: \\n31561:     /* The argument can optionally begin with \"-\" or \"--\" */\\n31562:     if( zCmd[0]==\\'-\\' && zCmd[1] ){\\n31563:       zCmd++;\\n31564:       if( zCmd[0]==\\'-\\' && zCmd[1] ) zCmd++;\\n31565:     }\\n31566: \\n31567:     /* --help lists all test-controls */\\n31568:     if( cli_strcmp(zCmd,\"help\")==0 ){\\n31569:       sqlite3_fputs(\"Available test-controls:\\\\n\", p->out);\\n31570:       for(i=0; i<ArraySize(aCtrl); i++){\\n31571:         if( aCtrl[i].unSafe && !ShellHasFlag(p,SHFLG_TestingMode) ) continue;\\n31572:         sqlite3_fprintf(p->out, \"  .testctrl %s %s\\\\n\",\\n31573:               aCtrl[i].zCtrlName, aCtrl[i].zUsage);\\n31574:       }\\n31575:       rc = 1;\\n31576:       goto meta_command_exit;\\n31577:     }\\n31578: \\n31579:     /* convert testctrl text option to value. allow any unique prefix\\n31580:     ** of the option name, or a numerical value. */\\n31581:     n2 = strlen30(zCmd);\\n31582:     for(i=0; i<ArraySize(aCtrl); i++){\\n31583:       if( aCtrl[i].unSafe && !ShellHasFlag(p,SHFLG_TestingMode) ) continue;\\n31584:       if( cli_strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 ){\\n31585:         if( testctrl<0 ){\\n31586:           testctrl = aCtrl[i].ctrlCode;\\n31587:           iCtrl = i;\\n31588:         }else{\\n31589:           sqlite3_fprintf(stderr,\"Error: ambiguous test-control: \\\\\"%s\\\\\"\\\\n\"\\n31590:                 \"Use \\\\\".testctrl --help\\\\\" for help\\\\n\", zCmd);\\n31591:           rc = 1;\\n31592:           goto meta_command_exit;\\n31593:         }\\n31594:       }\\n31595:     }\\n31596:     if( testctrl<0 ){\\n31597:       sqlite3_fprintf(stderr,\"Error: unknown test-control: %s\\\\n\"\\n31598:             \"Use \\\\\".testctrl --help\\\\\" for help\\\\n\", zCmd);\\n31599:     }else{\\n31600:       switch(testctrl){\\n31601: \\n31602:         /* Special processing for .testctrl opt MASK ...\\n31603:         ** Each MASK argument can be one of:\\n31604:         **\\n31605:         **      +LABEL       Enable the named optimization \\n31606:         **\\n31607:         **      -LABEL       Disable the named optimization\\n31608:         **\\n31609:         **      INTEGER      Mask of optimizations to disable\\n31610:         */\\n31611:         case SQLITE_TESTCTRL_OPTIMIZATIONS: {\\n31612:           static const struct {\\n31613:              unsigned int mask;    /* Mask for this optimization */\\n31614:              unsigned int bDsply;  /* Display this on output */\\n31615:              const char *zLabel;   /* Name of optimization */\\n31616:           } aLabel[] = {\\n31617:             { 0x00000001, 1, \"QueryFlattener\" },\\n31618:             { 0x00000001, 0, \"Flatten\" },\\n31619:             { 0x00000002, 1, \"WindowFunc\" },\\n31620:             { 0x00000004, 1, \"GroupByOrder\" },\\n31621:             { 0x00000008, 1, \"FactorOutConst\" },\\n31622:             { 0x00000010, 1, \"DistinctOpt\" },\\n31623:             { 0x00000020, 1, \"CoverIdxScan\" },\\n31624:             { 0x00000040, 1, \"OrderByIdxJoin\" },\\n31625:             { 0x00000080, 1, \"Transitive\" },\\n31626:             { 0x00000100, 1, \"OmitNoopJoin\" },\\n31627:             { 0x00000200, 1, \"CountOfView\" },\\n31628:             { 0x00000400, 1, \"CurosrHints\" },\\n31629:             { 0x00000800, 1, \"Stat4\" },\\n31630:             { 0x00001000, 1, \"PushDown\" },\\n31631:             { 0x00002000, 1, \"SimplifyJoin\" },\\n31632:             { 0x00004000, 1, \"SkipScan\" },\\n31633:             { 0x00008000, 1, \"PropagateConst\" },\\n31634:             { 0x00010000, 1, \"MinMaxOpt\" },\\n31635:             { 0x00020000, 1, \"SeekScan\" },\\n31636:             { 0x00040000, 1, \"OmitOrderBy\" },\\n31637:             { 0x00080000, 1, \"BloomFilter\" },\\n31638:             { 0x00100000, 1, \"BloomPulldown\" },\\n31639:             { 0x00200000, 1, \"BalancedMerge\" },\\n31640:             { 0x00400000, 1, \"ReleaseReg\" },\\n31641:             { 0x00800000, 1, \"FlttnUnionAll\" },\\n31642:             { 0x01000000, 1, \"IndexedEXpr\" },\\n31643:             { 0x02000000, 1, \"Coroutines\" },\\n31644:             { 0x04000000, 1, \"NullUnusedCols\" },\\n31645:             { 0x08000000, 1, \"OnePass\" },\\n31646:             { 0x10000000, 1, \"OrderBySubq\" },\\n31647:             { 0x20000000, 1, \"StarQuery\" },\\n31648:             { 0xffffffff, 0, \"All\" },\\n31649:           };\\n31650:           unsigned int curOpt;\\n31651:           unsigned int newOpt;\\n31652:           unsigned int m;\\n31653:           int ii;\\n31654:           int nOff;\\n31655:           sqlite3_test_control(SQLITE_TESTCTRL_GETOPT, p->db, &curOpt);\\n31656:           newOpt = curOpt;\\n31657:           for(ii=2; ii<nArg; ii++){\\n31658:             const char *z = azArg[ii];\\n31659:             int useLabel = 0;\\n31660:             const char *zLabel = 0;\\n31661:             if( (z[0]==\\'+\\'|| z[0]==\\'-\\') && !IsDigit(z[1]) ){\\n31662:               useLabel = z[0];\\n31663:               zLabel = &z[1];\\n31664:             }else if( !IsDigit(z[0]) && z[0]!=0 && !IsDigit(z[1]) ){\\n31665:               useLabel = \\'+\\';\\n31666:               zLabel = z;\\n31667:             }else{\\n31668:               newOpt = (unsigned int)strtol(z,0,0);\\n31669:             }\\n31670:             if( useLabel ){\\n31671:               int jj;\\n31672:               for(jj=0; jj<ArraySize(aLabel); jj++){\\n31673:                 if( sqlite3_stricmp(zLabel, aLabel[jj].zLabel)==0 ) break;\\n31674:               }\\n31675:               if( jj>=ArraySize(aLabel) ){\\n31676:                 sqlite3_fprintf(stderr,\\n31677:                     \"Error: no such optimization: \\\\\"%s\\\\\"\\\\n\", zLabel);\\n31678:                 sqlite3_fputs(\"Should be one of:\", stderr);\\n31679:                 for(jj=0; jj<ArraySize(aLabel); jj++){\\n31680:                   sqlite3_fprintf(stderr,\" %s\", aLabel[jj].zLabel);\\n31681:                 }\\n31682:                 sqlite3_fputs(\"\\\\n\", stderr);\\n31683:                 rc = 1;\\n31684:                 goto meta_command_exit;\\n31685:               }\\n31686:               if( useLabel==\\'+\\' ){\\n31687:                 newOpt &= ~aLabel[jj].mask;\\n31688:               }else{\\n31689:                 newOpt |= aLabel[jj].mask;\\n31690:               }\\n31691:             }\\n31692:           }\\n31693:           if( curOpt!=newOpt ){\\n31694:             sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,p->db,newOpt);\\n31695:           }\\n31696:           for(ii=nOff=0, m=1; ii<32; ii++, m <<= 1){\\n31697:             if( m & newOpt ) nOff++;\\n31698:           }\\n31699:           if( nOff<12 ){\\n31700:             sqlite3_fputs(\"+All\", p->out);\\n31701:             for(ii=0; ii<ArraySize(aLabel); ii++){\\n31702:               if( !aLabel[ii].bDsply  ) continue;\\n31703:               if( (newOpt & aLabel[ii].mask)!=0 ){\\n31704:                 sqlite3_fprintf(p->out, \" -%s\", aLabel[ii].zLabel);\\n31705:               }\\n31706:             }\\n31707:           }else{\\n31708:             sqlite3_fputs(\"-All\", p->out);\\n31709:             for(ii=0; ii<ArraySize(aLabel); ii++){\\n31710:               if( !aLabel[ii].bDsply  ) continue;\\n31711:               if( (newOpt & aLabel[ii].mask)==0 ){\\n31712:                 sqlite3_fprintf(p->out, \" +%s\", aLabel[ii].zLabel);\\n31713:               }\\n31714:             }\\n31715:           }\\n31716:           sqlite3_fputs(\"\\\\n\", p->out);\\n31717:           rc2 = isOk = 3;\\n31718:           break;\\n31719:         }\\n31720: \\n31721:         /* sqlite3_test_control(int, db, int) */\\n31722:         case SQLITE_TESTCTRL_FK_NO_ACTION:\\n31723:           if( nArg==3 ){\\n31724:             unsigned int opt = (unsigned int)strtol(azArg[2], 0, 0);\\n31725:             rc2 = sqlite3_test_control(testctrl, p->db, opt);\\n31726:             isOk = 3;\\n31727:           }\\n31728:           break;\\n31729: \\n31730:         /* sqlite3_test_control(int) */\\n31731:         case SQLITE_TESTCTRL_PRNG_SAVE:\\n31732:         case SQLITE_TESTCTRL_PRNG_RESTORE:\\n31733:         case SQLITE_TESTCTRL_BYTEORDER:\\n31734:           if( nArg==2 ){\\n31735:             rc2 = sqlite3_test_control(testctrl);\\n31736:             isOk = testctrl==SQLITE_TESTCTRL_BYTEORDER ? 1 : 3;\\n31737:           }\\n31738:           break;\\n31739: \\n31740:         /* sqlite3_test_control(int, uint) */\\n31741:         case SQLITE_TESTCTRL_PENDING_BYTE:\\n31742:           if( nArg==3 ){\\n31743:             unsigned int opt = (unsigned int)integerValue(azArg[2]);\\n31744:             rc2 = sqlite3_test_control(testctrl, opt);\\n31745:             isOk = 3;\\n31746:           }\\n31747:           break;\\n31748: \\n31749:         /* sqlite3_test_control(int, int, sqlite3*) */\\n31750:         case SQLITE_TESTCTRL_PRNG_SEED:\\n31751:           if( nArg==3 || nArg==4 ){\\n31752:             int ii = (int)integerValue(azArg[2]);\\n31753:             sqlite3 *db;\\n31754:             if( ii==0 && cli_strcmp(azArg[2],\"random\")==0 ){\\n31755:               sqlite3_randomness(sizeof(ii),&ii);\\n31756:               sqlite3_fprintf(stdout, \"-- random seed: %d\\\\n\", ii);\\n31757:             }\\n31758:             if( nArg==3 ){\\n31759:               db = 0;\\n31760:             }else{\\n31761:               db = p->db;\\n31762:               /* Make sure the schema has been loaded */\\n31763:               sqlite3_table_column_metadata(db, 0, \"x\", 0, 0, 0, 0, 0, 0);\\n31764:             }\\n31765:             rc2 = sqlite3_test_control(testctrl, ii, db);\\n31766:             isOk = 3;\\n31767:           }\\n31768:           break;\\n31769: \\n31770:         /* sqlite3_test_control(int, int) */\\n31771:         case SQLITE_TESTCTRL_ASSERT:\\n31772:         case SQLITE_TESTCTRL_ALWAYS:\\n31773:           if( nArg==3 ){\\n31774:             int opt = booleanValue(azArg[2]);\\n31775:             rc2 = sqlite3_test_control(testctrl, opt);\\n31776:             isOk = 1;\\n31777:           }\\n31778:           break;\\n31779: \\n31780:         /* sqlite3_test_control(int, int) */\\n31781:         case SQLITE_TESTCTRL_LOCALTIME_FAULT:\\n31782:         case SQLITE_TESTCTRL_NEVER_CORRUPT:\\n31783:           if( nArg==3 ){\\n31784:             int opt = booleanValue(azArg[2]);\\n31785:             rc2 = sqlite3_test_control(testctrl, opt);\\n31786:             isOk = 3;\\n31787:           }\\n31788:           break;\\n31789: \\n31790:         /* sqlite3_test_control(sqlite3*) */\\n31791:         case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:\\n31792:           rc2 = sqlite3_test_control(testctrl, p->db);\\n31793:           isOk = 3;\\n31794:           break;\\n31795: \\n31796:         case SQLITE_TESTCTRL_IMPOSTER:\\n31797:           if( nArg==5 ){\\n31798:             rc2 = sqlite3_test_control(testctrl, p->db,\\n31799:                           azArg[2],\\n31800:                           integerValue(azArg[3]),\\n31801:                           integerValue(azArg[4]));\\n31802:             isOk = 3;\\n31803:           }\\n31804:           break;\\n31805: \\n31806:         case SQLITE_TESTCTRL_SEEK_COUNT: {\\n31807:           u64 x = 0;\\n31808:           rc2 = sqlite3_test_control(testctrl, p->db, &x);\\n31809:           sqlite3_fprintf(p->out, \"%llu\\\\n\", x);\\n31810:           isOk = 3;\\n31811:           break;\\n31812:         }\\n31813: \\n31814: #ifdef YYCOVERAGE\\n31815:         case SQLITE_TESTCTRL_PARSER_COVERAGE: {\\n31816:           if( nArg==2 ){\\n31817:             sqlite3_test_control(testctrl, p->out);\\n31818:             isOk = 3;\\n31819:           }\\n31820:           break;\\n31821:         }\\n31822: #endif\\n31823: #ifdef SQLITE_DEBUG\\n31824:         case SQLITE_TESTCTRL_TUNE: {\\n31825:           if( nArg==4 ){\\n31826:             int id = (int)integerValue(azArg[2]);\\n31827:             int val = (int)integerValue(azArg[3]);\\n31828:             sqlite3_test_control(testctrl, id, &val);\\n31829:             isOk = 3;\\n31830:           }else if( nArg==3 ){\\n31831:             int id = (int)integerValue(azArg[2]);\\n31832:             sqlite3_test_control(testctrl, -id, &rc2);\\n31833:             isOk = 1;\\n31834:           }else if( nArg==2 ){\\n31835:             int id = 1;\\n31836:             while(1){\\n31837:               int val = 0;\\n31838:               rc2 = sqlite3_test_control(testctrl, -id, &val);\\n31839:               if( rc2!=SQLITE_OK ) break;\\n31840:               if( id>1 ) sqlite3_fputs(\"  \", p->out);\\n31841:               sqlite3_fprintf(p->out, \"%d: %d\", id, val);\\n31842:               id++;\\n31843:             }\\n31844:             if( id>1 ) sqlite3_fputs(\"\\\\n\", p->out);\\n31845:             isOk = 3;\\n31846:           }\\n31847:           break;\\n31848:         }\\n31849: #endif\\n31850:         case SQLITE_TESTCTRL_SORTER_MMAP:\\n31851:           if( nArg==3 ){\\n31852:             int opt = (unsigned int)integerValue(azArg[2]);\\n31853:             rc2 = sqlite3_test_control(testctrl, p->db, opt);\\n31854:             isOk = 3;\\n31855:           }\\n31856:           break;\\n31857:         case SQLITE_TESTCTRL_JSON_SELFCHECK:\\n31858:           if( nArg==2 ){\\n31859:             rc2 = -1;\\n31860:             isOk = 1;\\n31861:           }else{\\n31862:             rc2 = booleanValue(azArg[2]);\\n31863:             isOk = 3;\\n31864:           }\\n31865:           sqlite3_test_control(testctrl, &rc2);\\n31866:           break;\\n31867:         case SQLITE_TESTCTRL_FAULT_INSTALL: {\\n31868:           int kk;\\n31869:           int bShowHelp = nArg<=2;\\n31870:           isOk = 3;\\n31871:           for(kk=2; kk<nArg; kk++){\\n31872:             const char *z = azArg[kk];\\n31873:             if( z[0]==\\'-\\' && z[1]==\\'-\\' ) z++;\\n31874:             if( cli_strcmp(z,\"off\")==0 ){\\n31875:               sqlite3_test_control(testctrl, 0);\\n31876:             }else if( cli_strcmp(z,\"on\")==0 ){\\n31877:               faultsim_state.iCnt = faultsim_state.nSkip;\\n31878:               if( faultsim_state.iErr==0 ) faultsim_state.iErr = 1;\\n31879:               faultsim_state.nHit = 0;\\n31880:               sqlite3_test_control(testctrl, faultsim_callback);\\n31881:             }else if( cli_strcmp(z,\"reset\")==0 ){\\n31882:               faultsim_state.iCnt = faultsim_state.nSkip;\\n31883:               faultsim_state.nHit = 0;\\n31884:               sqlite3_test_control(testctrl, faultsim_callback);\\n31885:             }else if( cli_strcmp(z,\"status\")==0 ){\\n31886:               sqlite3_fprintf(p->out, \"faultsim.iId:       %d\\\\n\",\\n31887:                               faultsim_state.iId);\\n31888:               sqlite3_fprintf(p->out, \"faultsim.iErr:      %d\\\\n\",\\n31889:                               faultsim_state.iErr);\\n31890:               sqlite3_fprintf(p->out, \"faultsim.iCnt:      %d\\\\n\",\\n31891:                               faultsim_state.iCnt);\\n31892:               sqlite3_fprintf(p->out, \"faultsim.nHit:      %d\\\\n\",\\n31893:                               faultsim_state.nHit);\\n31894:               sqlite3_fprintf(p->out, \"faultsim.iInterval: %d\\\\n\",\\n31895:                               faultsim_state.iInterval);\\n31896:               sqlite3_fprintf(p->out, \"faultsim.eVerbose:  %d\\\\n\",\\n31897:                               faultsim_state.eVerbose);\\n31898:               sqlite3_fprintf(p->out, \"faultsim.nRepeat:   %d\\\\n\",\\n31899:                               faultsim_state.nRepeat);\\n31900:               sqlite3_fprintf(p->out, \"faultsim.nSkip:     %d\\\\n\",\\n31901:                               faultsim_state.nSkip);\\n31902:             }else if( cli_strcmp(z,\"-v\")==0 ){\\n31903:               if( faultsim_state.eVerbose<2 ) faultsim_state.eVerbose++;\\n31904:             }else if( cli_strcmp(z,\"-q\")==0 ){\\n31905:               if( faultsim_state.eVerbose>0 ) faultsim_state.eVerbose--;\\n31906:             }else if( cli_strcmp(z,\"-id\")==0 && kk+1<nArg ){\\n31907:               faultsim_state.iId = atoi(azArg[++kk]);\\n31908:             }else if( cli_strcmp(z,\"-errcode\")==0 && kk+1<nArg ){\\n31909:               faultsim_state.iErr = atoi(azArg[++kk]);\\n31910:             }else if( cli_strcmp(z,\"-interval\")==0 && kk+1<nArg ){\\n31911:               faultsim_state.iInterval = atoi(azArg[++kk]);\\n31912:             }else if( cli_strcmp(z,\"-repeat\")==0 && kk+1<nArg ){\\n31913:               faultsim_state.nRepeat = atoi(azArg[++kk]);\\n31914:            }else if( cli_strcmp(z,\"-skip\")==0 && kk+1<nArg ){\\n31915:               faultsim_state.nSkip = atoi(azArg[++kk]);\\n31916:             }else if( cli_strcmp(z,\"-?\")==0 || sqlite3_strglob(\"*help*\",z)==0){\\n31917:               bShowHelp = 1;\\n31918:             }else{\\n31919:               sqlite3_fprintf(stderr,\\n31920:                   \"Unrecognized fault_install argument: \\\\\"%s\\\\\"\\\\n\",\\n31921:                   azArg[kk]);\\n31922:               rc = 1;\\n31923:               bShowHelp = 1;\\n31924:               break;\\n31925:             }\\n31926:           }\\n31927:           if( bShowHelp ){\\n31928:             sqlite3_fputs(\\n31929:                \"Usage: .testctrl fault_install ARGS\\\\n\"\\n31930:                \"Possible arguments:\\\\n\"\\n31931:                \"   off               Disable faultsim\\\\n\"\\n31932:                \"   on                Activate faultsim\\\\n\"\\n31933:                \"   reset             Reset the trigger counter\\\\n\"\\n31934:                \"   status            Show current status\\\\n\"\\n31935:                \"   -v                Increase verbosity\\\\n\"\\n31936:                \"   -q                Decrease verbosity\\\\n\"\\n31937:                \"   --errcode N       When triggered, return N as error code\\\\n\"\\n31938:                \"   --id ID           Trigger only for the ID specified\\\\n\"\\n31939:                \"   --interval N      Trigger only after every N-th call\\\\n\"\\n31940:                \"   --repeat N        Turn off after N hits.  0 means never\\\\n\"\\n31941:                \"   --skip N          Skip the first N encounters\\\\n\"\\n31942:                ,p->out\\n31943:             );\\n31944:           }\\n31945:           break;\\n31946:         }\\n31947:       }\\n31948:     }\\n31949:     if( isOk==0 && iCtrl>=0 ){\\n31950:       sqlite3_fprintf(p->out,\\n31951:           \"Usage: .testctrl %s %s\\\\n\", zCmd,aCtrl[iCtrl].zUsage);\\n31952:       rc = 1;\\n31953:     }else if( isOk==1 ){\\n31954:       sqlite3_fprintf(p->out, \"%d\\\\n\", rc2);\\n31955:     }else if( isOk==2 ){\\n31956:       sqlite3_fprintf(p->out, \"0x%08x\\\\n\", rc2);\\n31957:     }\\n31958:   }else\\n31959: #endif /* !defined(SQLITE_UNTESTABLE) */\\n31960: \\n31961:   if( c==\\'t\\' && n>4 && cli_strncmp(azArg[0], \"timeout\", n)==0 ){\\n31962:     open_db(p, 0);\\n31963:     sqlite3_busy_timeout(p->db, nArg>=2 ? (int)integerValue(azArg[1]) : 0);\\n31964:   }else\\n31965: \\n31966:   if( c==\\'t\\' && n>=5 && cli_strncmp(azArg[0], \"timer\", n)==0 ){\\n31967:     if( nArg==2 ){\\n31968:       enableTimer = booleanValue(azArg[1]);\\n31969:       if( enableTimer && !HAS_TIMER ){\\n31970:         eputz(\"Error: timer not available on this system.\\\\n\");\\n31971:         enableTimer = 0;\\n31972:       }\\n31973:     }else{\\n31974:       eputz(\"Usage: .timer on|off\\\\n\");\\n31975:       rc = 1;\\n31976:     }\\n31977:   }else\\n31978: \\n31979: #ifndef SQLITE_OMIT_TRACE\\n31980:   if( c==\\'t\\' && cli_strncmp(azArg[0], \"trace\", n)==0 ){\\n31981:     int mType = 0;\\n31982:     int jj;\\n31983:     open_db(p, 0);\\n31984:     for(jj=1; jj<nArg; jj++){\\n31985:       const char *z = azArg[jj];\\n31986:       if( z[0]==\\'-\\' ){\\n31987:         if( optionMatch(z, \"expanded\") ){\\n31988:           p->eTraceType = SHELL_TRACE_EXPANDED;\\n31989:         }\\n31990: #ifdef SQLITE_ENABLE_NORMALIZE\\n31991:         else if( optionMatch(z, \"normalized\") ){\\n31992:           p->eTraceType = SHELL_TRACE_NORMALIZED;\\n31993:         }\\n31994: #endif\\n31995:         else if( optionMatch(z, \"plain\") ){\\n31996:           p->eTraceType = SHELL_TRACE_PLAIN;\\n31997:         }\\n31998:         else if( optionMatch(z, \"profile\") ){\\n31999:           mType |= SQLITE_TRACE_PROFILE;\\n32000:         }\\n32001:         else if( optionMatch(z, \"row\") ){\\n32002:           mType |= SQLITE_TRACE_ROW;\\n32003:         }\\n32004:         else if( optionMatch(z, \"stmt\") ){\\n32005:           mType |= SQLITE_TRACE_STMT;\\n32006:         }\\n32007:         else if( optionMatch(z, \"close\") ){\\n32008:           mType |= SQLITE_TRACE_CLOSE;\\n32009:         }\\n32010:         else {\\n32011:           sqlite3_fprintf(stderr,\"Unknown option \\\\\"%s\\\\\" on \\\\\".trace\\\\\"\\\\n\", z);\\n32012:           rc = 1;\\n32013:           goto meta_command_exit;\\n32014:         }\\n32015:       }else{\\n32016:         output_file_close(p->traceOut);\\n32017:         p->traceOut = output_file_open(z);\\n32018:       }\\n32019:     }\\n']"
  },
  {
    "role": "assistant",
    "content": "Step 1: Analyze the function `do_meta_command` in the SQLite project.\n\n- `do_meta_command` is a function defined in the SQLite shell source code (`shell.c`).\n- It is a static or internal function (not exported as a public API).\n- Its purpose is to process \"meta-commands\" in the SQLite CLI shell. Meta-commands are commands starting with a dot (`.`), such as `.tables`, `.schema`, `.exit`, etc.\n- The function is called internally by the SQLite shell command loop when the user inputs a line starting with a dot.\n- It is not part of the SQLite library API; it is part of the CLI shell program.\n\nStep 2: Determine if `do_meta_command` is directly invocable from a user interaction boundary.\n\n- The user interacts with the SQLite shell via stdin (terminal input).\n- The shell reads lines from the user, and if the line starts with a dot, it calls `do_meta_command` to handle that command.\n- Therefore, the user can directly trigger `do_meta_command` by typing a meta-command in the SQLite shell.\n- The entry point is the shell's main loop, which reads user input and calls `do_meta_command` accordingly.\n\nStep 3: Minimal test case to reach `do_meta_command`.\n\n- Build the SQLite shell executable (usually `sqlite3`).\n- Run the shell: `./sqlite3`\n- At the prompt, enter a meta-command, e.g., `.tables`\n- This input causes the shell to call `do_meta_command` to process `.tables`.\n\nSummary:\n\n- `do_meta_command` is not a public API function but is directly reachable from user input in the SQLite CLI shell.\n- The user interaction boundary is the shell's stdin.\n- The function is invoked directly on user input starting with a dot.\n\nHence, `do_meta_command` is a user-accessible entry point in the context of the SQLite shell program.\n\n---\n\nOutput:\n\n```\nBuild and run the SQLite shell:\n\n1. Build SQLite shell (assuming source is extracted):\n   $ gcc shell.c sqlite3.c -o sqlite3 -lpthread -ldl -lm\n\n2. Run the shell:\n   $ ./sqlite3\n\n3. At the prompt, enter a meta-command:\n   sqlite> .tables\n\nThis input causes the shell to invoke do_meta_command.\n\n@@@entry point@@@\n```"
  }
]